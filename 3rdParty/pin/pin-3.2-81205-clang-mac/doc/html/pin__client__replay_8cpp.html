<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Pin: pin_client_replay.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Pin
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_74389ed8173ad57b461b9d623a1f3867.html">Source</a></li><li class="navelem"><a class="el" href="dir_e203be77b60a873c3af063de5cff82a1.html">pin</a></li><li class="navelem"><a class="el" href="dir_eb16a3aedc0606997205bf9711a4b5ca.html">pin</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pin_client_replay.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="level__base_8H.html">level_base.H</a>&quot;</code><br />
<code>#include &quot;level_core.H&quot;</code><br />
<code>#include &quot;level_imgio.H&quot;</code><br />
<code>#include &quot;level_vmclient.H&quot;</code><br />
<code>#include &quot;level_pinclient.H&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab17933d09ef2378f9a385e00e041911e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pin__client__replay_8cpp.html#ab17933d09ef2378f9a385e00e041911e">LEVEL_PINCLIENT::REPLAY_IMAGE_TYPE</a> { <br />
&#160;&#160;<a class="el" href="pin__client__replay_8cpp.html#ab17933d09ef2378f9a385e00e041911ea736a565b689088f245e364274dc94e52">LEVEL_PINCLIENT::REPLAY_IMAGE_TYPE_REGULAR</a> = 0, 
<br />
&#160;&#160;<a class="el" href="pin__client__replay_8cpp.html#ab17933d09ef2378f9a385e00e041911ea876a84ec97b14930a5890e80a39c7eab">LEVEL_PINCLIENT::REPLAY_IMAGE_TYPE_MAIN_EXE</a> = 1, 
<br />
&#160;&#160;<a class="el" href="pin__client__replay_8cpp.html#ab17933d09ef2378f9a385e00e041911ea387edc1bb726b8dc3d6f8d99f5afb219">LEVEL_PINCLIENT::REPLAY_IMAGE_TYPE_INTERPRETER</a> = 2
<br />
 }</td></tr>
<tr class="separator:ab17933d09ef2378f9a385e00e041911e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af2d0628d04cad7be70e60df70079bc94"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pin__client__replay_8cpp.html#af2d0628d04cad7be70e60df70079bc94">LEVEL_PINCLIENT::PIN_ReplaySyscallEntry</a> (<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, SYSCALL_STANDARD std)</td></tr>
<tr class="separator:af2d0628d04cad7be70e60df70079bc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45dda023dabf1443df8fd629a2557a8d"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pin__client__replay_8cpp.html#a45dda023dabf1443df8fd629a2557a8d">LEVEL_PINCLIENT::PIN_ReplaySyscallExit</a> (<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *ctxt, SYSCALL_STANDARD std)</td></tr>
<tr class="separator:a45dda023dabf1443df8fd629a2557a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca18852e033c5cefb830bb74b24bbb41"><td class="memItemLeft" align="right" valign="top">NORETURN VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__PROCESS__API.html#gaca18852e033c5cefb830bb74b24bbb41">LEVEL_PINCLIENT::PIN_ExitApplication</a> (INT32 status)</td></tr>
<tr class="separator:gaca18852e033c5cefb830bb74b24bbb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e650a8a9a2bd8fce8e3319d268c421"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49e650a8a9a2bd8fce8e3319d268c421"></a>
LOCALFUN const char *&#160;</td><td class="memItemRight" valign="bottom"><b>LEVEL_PINCLIENT::ContextChangeReasonName</b> (<a class="el" href="group__PIN__CONTROL.html#ga8e4e6511a0e09fdc5ec7d6dbf395b3a8">CONTEXT_CHANGE_REASON</a> r)</td></tr>
<tr class="separator:a49e650a8a9a2bd8fce8e3319d268c421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ae9555107bb81ab2499e3519e74525"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pin__client__replay_8cpp.html#a98ae9555107bb81ab2499e3519e74525">LEVEL_PINCLIENT::PIN_ReplayContextChange</a> (<a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a> tid, const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *from, <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *to, <a class="el" href="group__PIN__CONTROL.html#ga8e4e6511a0e09fdc5ec7d6dbf395b3a8">CONTEXT_CHANGE_REASON</a> reason, INT32 info)</td></tr>
<tr class="separator:a98ae9555107bb81ab2499e3519e74525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d4291b91c0f4cdf30e9f789ac9f6ab"><td class="memItemLeft" align="right" valign="top">IMG&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pin__client__replay_8cpp.html#ae6d4291b91c0f4cdf30e9f789ac9f6ab">LEVEL_PINCLIENT::PIN_ReplayImageLoad</a> (const char *imageName, const char *fileName, ADDRINT loadOffset, REPLAY_IMAGE_TYPE imageType)</td></tr>
<tr class="separator:ae6d4291b91c0f4cdf30e9f789ac9f6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52379b3dd9e24ddeda2a8d828f89050a"><td class="memItemLeft" align="right" valign="top">VOID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pin__client__replay_8cpp.html#a52379b3dd9e24ddeda2a8d828f89050a">LEVEL_PINCLIENT::PIN_ReplayImageUnload</a> (IMG img)</td></tr>
<tr class="separator:a52379b3dd9e24ddeda2a8d828f89050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d243673a6238afe734e70be901c7af1"><td class="memItemLeft" align="right" valign="top">BOOL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pin__client__replay_8cpp.html#a8d243673a6238afe734e70be901c7af1">LEVEL_PINCLIENT::PIN_WasMemoryReservedInLoadTime</a> ()</td></tr>
<tr class="separator:a8d243673a6238afe734e70be901c7af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Additional client side interface to pin vm containing the interfaces useful for a replay tool. These mainly allow a PinTool to request that Pin execute callbacks associated with specific events. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="file_ab17933d09ef2378f9a385e00e041911e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="pin__client__replay_8cpp.html#ab17933d09ef2378f9a385e00e041911e">LEVEL_PINCLIENT::REPLAY_IMAGE_TYPE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Image types for <a class="el" href="pin__client__replay_8cpp.html#ae6d4291b91c0f4cdf30e9f789ac9f6ab">PIN_ReplayImageLoad()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab17933d09ef2378f9a385e00e041911ea736a565b689088f245e364274dc94e52"></a>REPLAY_IMAGE_TYPE_REGULAR&#160;</td><td class="fielddoc">
<p>Regular image. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab17933d09ef2378f9a385e00e041911ea876a84ec97b14930a5890e80a39c7eab"></a>REPLAY_IMAGE_TYPE_MAIN_EXE&#160;</td><td class="fielddoc">
<p>Main executable image. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab17933d09ef2378f9a385e00e041911ea387edc1bb726b8dc3d6f8d99f5afb219"></a>REPLAY_IMAGE_TYPE_INTERPRETER&#160;</td><td class="fielddoc">
<p>The image of the interpreter (loader) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="file_a98ae9555107bb81ab2499e3519e74525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_ReplayContextChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__PIN__CONTROL.html#ga8e4e6511a0e09fdc5ec7d6dbf395b3a8">CONTEXT_CHANGE_REASON</a>&#160;</td>
          <td class="paramname"><em>reason</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INT32&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is intended for use by tools that replay the execution of an application and need to replay an asynchronous context change that was received by the application at record time. This API is not intended as a general way to send a forced context change (signal, exception, APC) to the application. To do that, see <a class="el" href="group__EXCEPTION__API.html#ga656279818bb8972fbdac576b57854561">PIN_RaiseException()</a>.</p>
<p>Calling this API causes Pin to call back on the tool's context-changed notification function if one was set up with <a class="el" href="group__PIN__CONTROL.html#ga786fd61c9be3c42a1a6deefc71dffadf">PIN_AddContextChangeFunction()</a>. Thus, the tool is notified about the context change as though the application really received it. Calling this API may also notify an external debugger if one is attached to Pin via the -appdebug switch, which gives the debugger a chance to stop execution of the application when it receives the replayed context change. (Whether this happens depends on the CONTEXT_CHANGE_REASON, and the expected behavior of the debugger on different platforms).</p>
<p><a class="el" href="pin__client__replay_8cpp.html#a98ae9555107bb81ab2499e3519e74525">PIN_ReplayContextChange()</a> does not return to its caller. If the <em>to</em> parameter is not NULL, execution resumes at that context after it has been potentially modified by the tool's context-changed call-back. If <em>reason</em> is CONTEXT_CHANGE_REASON_FATALSIGNAL, Pin emulates a fatal signal and execution terminates gracefully after calling the tool's Fini functions.</p>
<p>This API can be called from an analysis routine or a replacement routine, but not from a callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>The ID of the calling thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The register state prior to the context change (e.g. the register state at the point when the signal is received for CONTEXT_CHANGE_REASON_SIGNAL). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>The register state immediately after the context change. This should be NULL for CONTEXT_CHANGE_REASON_FATALSIGNAL. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reason</td><td>The type of the context change. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Additional information, depending on <em>reason</em>. (Ignored for <em>reason</em> codes not listed below.) <ul>
<li>CONTEXT_CHANGE_REASON_FATALSIGNAL: The Unix signal number. </li>
<li>CONTEXT_CHANGE_REASON_SIGNAL: The Unix signal number. </li>
<li>CONTEXT_CHANGE_REASON_EXCEPTION: The Windows exception code. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function does not return.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux &amp; Windows<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="file_ae6d4291b91c0f4cdf30e9f789ac9f6ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">IMG LEVEL_PINCLIENT::PIN_ReplayImageLoad </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>imageName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADDRINT&#160;</td>
          <td class="paramname"><em>loadOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="pin__client__replay_8cpp.html#ab17933d09ef2378f9a385e00e041911e">REPLAY_IMAGE_TYPE</a>&#160;</td>
          <td class="paramname"><em>imageType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ask Pin to perform all the functions it would normally do when it detects that a new shared library has been loaded. This is intended for use in a replay system, where the replay tool has recorded library load operations, and now wants to replay them.</p>
<p>The code calling this routine need <b>not</b> ensure that the loaded sections of the image have already been restored. Using this interface causes Pin to use its private copy of the image information to satisfy the IMG, SEC and RTN functions.</p>
<p>This routine can be called <b>before</b> PIN_StartProgram to set up image load operations for images which were loaded before Pin took control of the program at record time (on Unix systems these are normally the main executable and the dynamic linker; on Windows more system libraries may be present). When called at this point the image load callbacks are remembered internally, and replayed when PIN_StartProgram is called. (This is the same time they would have been made at record time, and ensures that all relevant callbacks have been registered).</p>
<p>PIN_ReplayImageLoad can also be called from analysis or callback routines, in which case the relevant callbacks are made immediately. If called from an analysis routine, the Pin client lock must be claimed before calling PIN_ReplayImageLoad (the Pin client lock is already held when in a callback routine, so there is no need to claim it again).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageName</td><td>name of the image visible to Pin tools </td></tr>
    <tr><td class="paramname">fileName</td><td>name of the file from which the image is read </td></tr>
    <tr><td class="paramname">loadOffset</td><td>offset from the address at which the image is naturally loaded to the address at which it has been loaded </td></tr>
    <tr><td class="paramname">imageType</td><td>Type of the image to load</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the image id of the loaded img, or IMG_INVALID() when called before PIN_StartProgram</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux (others to follow)<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="file_a52379b3dd9e24ddeda2a8d828f89050a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_ReplayImageUnload </td>
          <td>(</td>
          <td class="paramtype">IMG&#160;</td>
          <td class="paramname"><em>img</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ask Pin to perform all the functions it would normally do when it detects that a shared library has been unloaded. This is intended for use in a replay system, where the replay tool has recorded library unload operations, and now wants to replay them.</p>
<p>Note that a replay system need not explicitly call this function to cause image unload callbacks at the end of process execution. Pin will generate those callbacks itself provided that images were created using the PIN_ReplayImageLoad call. However, this function is required to handle explicit image unloads (for instance those caused by <code>dlclose()</code> )</p>
<p>PIN_ReplayImageUnload can be called from analysis or callback routines. If called from an analysis routine, the Pin client lock must be claimed before calling PIN_ReplayImageUnload (the Pin client lock is already held when in a callback routine, so there is no need to claim it again).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>the IMG to be unloaded</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The pin client lock is obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux (others to follow)<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="file_af2d0628d04cad7be70e60df70079bc94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_ReplaySyscallEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SYSCALL_STANDARD&#160;</td>
          <td class="paramname"><em>std</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is intended for use by tools that replay the execution of an application and need to behave as if a system call has been made, calling all callbacks registered with PIN_AddSysCallEntry function. However, no system call is actually performed.</p>
<p>This API can be called from an analysis routine or a replacement routine, but not from a call-back.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>The ID of the thread in which the system call appears to execute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The register state at the point when the system call appears to execute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">std</td><td>The calling standard of the system call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux,Windows,BSD<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="file_a45dda023dabf1443df8fd629a2557a8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VOID LEVEL_PINCLIENT::PIN_ReplaySyscallExit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__PIN__THREAD__API.html#ga645289be59039349ad77ad2fa7b0e2f3">THREADID</a>&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CONTEXT__API.html#ga73f8f88949aaecf53a6d23f56399c676">CONTEXT</a> *&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SYSCALL_STANDARD&#160;</td>
          <td class="paramname"><em>std</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This API is intended for use by tools that replay the execution of an application and need to behave as if a system call has been made, calling all callbacks registered with PIN_AddSysCallExit function. However, no system call is actually performed.</p>
<p>This API can be called from an analysis routine or a replacement routine, but not from a call-back.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tid</td><td>The ID of the thread in which the system call appears to execute. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The register state at the point after the system call has executed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">std</td><td>The calling standard of the system call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The vm and pin client locks are obtained during the call of this API.</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux,Windows,BSD<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
<a class="anchor" id="file_a8d243673a6238afe734e70be901c7af1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BOOL LEVEL_PINCLIENT::PIN_WasMemoryReservedInLoadTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return TRUE if PIN was successfully reserved the neccessary memory at application load time (specified on the -reserve_memory knob), and was successfully restricted the memory from the loader (specified on the -restrict_memory knob). It is guaranteed this is the return value is FALSE then none the memory specified in the mentioned knobs was reserved/restricted</p>
<dl class="section return"><dt>Returns</dt><dd>TRUE if all the memory was reserved/restricted</dd></dl>
<dl class="section user"><dt>Availability:</dt><dd><b>Mode:</b> JIT<br />
<b>O/S</b>: Linux<br />
<b>CPU:</b> All<br />
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
