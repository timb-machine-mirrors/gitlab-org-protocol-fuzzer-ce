<<<
[[Monitors_TcpPort]]
== TcpPort Monitor

*Monitor Categories*: *Automation*, *Data collection*, *Fault detection*

The _TcpPort_ monitor detects state changes on TCP ports. A state change is a transition in port status from Open to Closed or from Closed to Open. The _TcpPort_ monitor can be configured in the following ways:

* as an automation task (wait until a specified state occurs)
* fault detection (fault on a specific state)
* data collection (report the current state)

The monitor includes an event trigger (the _When_ parameter) that you can use to control when automation occurs. Interesting points to start monitoring include the following:

* At the start or end of a fuzzing run
* At the start or end of each test iteration
* After detecting a fault
* At the start of an iteration that immediately follows a fault
* When called from the StateModel


Fault detection for this monitor uses bucketing. The major hash (bucket category) is the port number. The minor hash is the monitor state (open or closed). Risk evaluation is not used.

=== Parameters

_Required:_

Host:: Hostname or IP address of the remote host
Port:: Port number to monitor

_Optional:_

Action::  Action to take (Automation, Data, Fault). Defaults to _Automation_.

[horizontal]
Automation;; Wait for the port to reach a specified state. The _When_ parameter determines when the monitor waits. The maximum waiting time can be configured by setting the _Timeout_ parameter.
Data;; On a fault, report the state of the port at end of the current iteration.
Fault;; At end of the current iteration, generate a fault if the port is in a
specified state.

[vertical]
When::
+
Event that specifies when to perform monitoring. The default setting is _OnCall_. The following settings are defined:
+
[cols="1,2" options="header",halign="center"]
|==========================================================
|"When" Setting              |Description
|OnStart                     |Monitoring occurs once at the start of the fuzzing session.
|OnEnd                       |Monitoring occurs once at the end of the fuzzing session.
|OnIterationStart            |Monitoring occurs at the start of each iteration.
|OnIterationEnd              |Monitoring occurs at the end of each iteration.
|OnFault                     |Monitoring occurs immediately following a fault.
|OnIterationStartAfterFault  |Monitoring occurs after a fault occurs and the current iteration completes. Then, at the start of the next iteration, monitoring begins.
|OnCall                      |Monitoring begins upon receipt of a message from the state machine.
|==========================================================
+
.WaitWhen Choices
image::{images}/Common/Monitors/Timings_All.png[scalewidth="75%"]

WaitOnCall:: Call message to start monitoring. This parameter only applies to the _OnCall_ setting.

State::
Port state to monitor. The default value is _Open_.
+
[horizontal]
Open;; The port is available for use.
Closed;; The port is not available.

Timeout:: Length of time to wait for an incoming connection to be established. Specify values in milliseconds, or specify -1 to indicate a timeout interval is not used.

=== Examples

ifdef::peachug[]

.Wait for a Port to Open  +
====================

This parameter example is from a setup that causes Peach to wait until the remote port is in an open state. No timeout interval is provided, so Peach will wait forever.


[cols="2,4" options="header",halign="center"]
|==========================================================
|Parameter    |Value
|Host         |192.168.133.4
|Port         |502
|WaitOnCall   |WaitForPort
|==========================================================
====================


.Wait for a Port to Close  +
====================

This parameter example is from a setup that causes Peach to wait until the remote port closes. No timeout interval is provided, so
Peach will wait forever.

[cols="2,4" options="header",halign="center"]
|==========================================================
|Parameter    |Value
|Host         |192.168.133.4
|Port         |502
|State        |Closed
|WaitOnCall   |WaitForPort
|==========================================================
====================


.Fault if the Port is Closed  +
====================

This parameter example is from a setup that inspects the state of the remote port at the end of an iteration. If the port is closed
at the end of an iteration, Peach generates a fault.

[cols="2,4" options="header",halign="center"]
|==========================================================
|Parameter    |Value
|Host         |192.168.133.4
|Port         |502
|Action       |Fault
|State        |Closed
|==========================================================
====================


.Report the Port State on Fault  +
====================

This parameter example is from a setup that uses the TcpPort monitor for data collection. If
another monitor detects or generates a fault during fuzzing, the TcpPort monitor reports the
state of the port when the fault occurs.

[cols="2,4" options="header",halign="center"]
|==========================================================
|Parameter    |Value
|Host         |192.168.133.4
|Port         |502
|Action       |Data
|==========================================================
====================

endif::peachug[]


ifndef::peachug[]

.Wait for the port to be open
===============================
In this example, the call action causes Peach to wait until the remote port is in an open state. No timeout interval is provided, so Peach will wait forever.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

  <DataModel name="TheDataModel">
    <Number size="32" signed="false" value="31337" />
  </DataModel>

  <StateModel name="State" initialState="Initial" >
    <State name="Initial">
      <Action type="output">
          <DataModel ref="TheDataModel"/>
      </Action>

      <Action type="call" method="WaitForPort" publisher="Peach.Agent" />
    </State>
  </StateModel>

  <Agent name="Local">
	<Monitor class="TcpPort">
        <Param name="Host" value="192.168.133.4" />
        <Param name="Port" value="502" />
        <Param name="WaitOnCall" value="WaitForPort" />
	</Monitor>
  </Agent>


  <Test name="Default">
    <StateModel ref="State"/>

    <Agent ref="Local" />

    <Publisher class="ConsoleHex"/>

    <Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
  </Test>
</Peach>
----

===============================

.Wait for the port to be closed
===============================
In this example, the call action causes Peach to wait until the remote port is in a closed state. Since no timeout is provided, Peach will wait forever.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

  <DataModel name="TheDataModel">
    <Number size="32" signed="false" value="31337" />
  </DataModel>

  <StateModel name="State" initialState="Initial" >
    <State name="Initial">
      <Action type="output">
          <DataModel ref="TheDataModel"/>
      </Action>

      <Action type="call" method="WaitForPort" publisher="Peach.Agent" />
    </State>
  </StateModel>

  <Agent name="Local">
	<Monitor class="TcpPort">
        <Param name="Host" value="192.168.133.4" />
        <Param name="Port" value="502" />
        <Param name="State" value="Closed" />
        <Param name="WaitOnCall" value="WaitForPort" />
	</Monitor>
  </Agent>


  <Test name="Default">
    <StateModel ref="State"/>

    <Agent ref="Local" />

    <Publisher class="ConsoleHex"/>

    <Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
  </Test>
</Peach>
----


===============================

.Fault if the port closed
===============================
In this example, Peach faults if the port is in the closed state at the end of an iteration.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

  <DataModel name="TheDataModel">
    <Number size="32" signed="false" value="31337" />
  </DataModel>

  <StateModel name="State" initialState="Initial" >
    <State name="Initial">
      <Action type="output">
          <DataModel ref="TheDataModel"/>
      </Action>
    </State>
  </StateModel>

  <Agent name="Local">
	<Monitor class="TcpPort">
        <Param name="Host" value="192.168.133.4" />
        <Param name="Port" value="502" />
        <Param name="Action" value="Fault" />
        <Param name="State" value="Closed" />
	</Monitor>
  </Agent>


  <Test name="Default">
    <StateModel ref="State"/>

    <Agent ref="Local" />

    <Publisher class="ConsoleHex"/>

    <Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
  </Test>
</Peach>
----



===============================

.Report the port state on fault
===============================
In this example, if a fault is triggered by another monitor, the TcpPort monitor reports the state of the port when the fault occurred.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

  <DataModel name="TheDataModel">
    <Number size="32" signed="false" value="31337" />
  </DataModel>

  <StateModel name="State" initialState="Initial" >
    <State name="Initial">
      <Action type="output">
          <DataModel ref="TheDataModel"/>
      </Action>
    </State>
  </StateModel>

  <Agent name="Local">
    <!-- Fault detection -->
    <Monitor class="Gdb">
      <Param name="Executable" value="/usr/bin/curl"/>
      <Param name="Arguments" value="http://localhost"/>
      <Param name="StartOnCall" value="ScoobySnacks"/>
    </Monitor>

    <!-- Data collection -->
	<Monitor class="TcpPort">
        <Param name="Host" value="192.168.133.4" />
        <Param name="Port" value="502" />
        <Param name="Action" value="Data" />
	</Monitor>
  </Agent>


  <Test name="Default">
    <StateModel ref="State"/>

    <Agent ref="Local" />

    <Publisher class="ConsoleHex"/>

    <Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
  </Test>
</Peach>
----

===============================

endif::peachug[]
