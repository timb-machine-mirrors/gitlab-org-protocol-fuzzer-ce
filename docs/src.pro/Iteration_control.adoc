[[Iteration_control]]

// 03/28/2014 - Lynn: Major edits

== Control Iteration

Control iterations verify the correct target operation for a long running target (one that is operational across multiple iterations). 

An example of a long running target is a network service that is started once at the beginning of the fuzzing session, and monitored to see if it faults. For targets that are not long running (like a process that is restarted on every iteration), control iterations are normally not necessary. 

NOTE: Control iterations must be explicitly enabled in the pit file.

Control iterations work in conjunction with xref:Iteration_record[record iterations]. The state model execution sequence is recorded during a record iteration. A control iteration will perform an iteration with no mutations occurring and compare the execution sequence with the recorded sequence. If the two do not match, a fault will be generated. For example, if 10 actions occur on the record iteration and only 6 occur on the control, Peach assumes that the target is in a bad state and generates a fault since the bad state is likely interesting (as a denial of service vulnerability) from a security standpoint. And when a fault is triggered, actions can be taken to restart the system.

// TODO insert visual images from slide deck

Control iterations are configured on the xref:Test[_Test_ element] using the _controlIteration_ attribute. The value provided is a positive integer that defines how often to perform a control iteration. A value of 1 will cause control iterations to be performed after each iteration.

.Syntax example
[source,xml]
----
<Test name="TheTest" controlIterations="1"> .... </Test>
----

See also xref:Iteration_control[control iterations] and xref:Iteration_fuzzing[fuzzing iterations].
