== Peach Web

Peach Web enables Peach to perform fuzz testing of various web services and web APIs.
Any web service or API system that utilizes HTTP as the transport layer with JSON, XML or formdata is supported.
Examples include REST, SOAP and JSON-API.

Testing is performed by sending valid traffic through Peaches web proxy to the test target.
As requests pass through the web proxy they are modified to create test cases.
Transport layer security (SSL/TLS) is supported along with client cert authentication.
Web socket traffic is also supported, but is not tested at this time (pass through only).

Peach Web has been designed to integrate into the development process to provide immediate feedback on API security.
This is an optional, but recommended method for usage.

=== Usage

This section provides some example usage patterns for Peach Web.

==== Development/Engineering Team

For teams building web services and web APIs, integration into the CI system or automated test system provides
a lot of advantages over traditional web testing processes.
Peach Web can also re-use automated tests to provide high test coverage with little effort.

Immediate feedback during CI build and test process::
	Peach Web becomes a step in your CI system.
	Builds that don't pass security testing can fail.
	Cost savings by fixing issues immediately.
	
Integration with existing automated tests::
	Because Peach Web operates as a web proxy, traffic must be sent through it to generate test cases.
	An one method to accomplish this is using existing automated tests based on Selenium, JUnit, pytest or other
	test frameworks.
	Peach provides integrations into these common automated testing platforms.
	This provides instant test coverage across your APIs with little upfront work.
	As new test cases are added they can automatically be used with Peach, lowering your cost
	of ownership.
	

==== Redteam or Penetration Tester

Use by individual testers such as redteam members or penetration testers can be achieved in several ways:

. Attack proxies can forward input into Peach for testing.
For example Burp Repeater can be used to forward requests through Peach multiple times.
. A custom traffic generator script can be written in a language known by the tester such as Python.
These scripts are easy and quick to author, in fact existing sample code can be used in many cases.
. Selenium Firefox plugin can be used to record a web session.
Selenium then exports to formats like JUnit that have Peach integrations.

=== CI Integration

Peach Web currently provides generic CI integration via command line usage.
Our next release will include specific plugins or integrations with leading CI systems.

The generic CI integration script is available in SDK\webproxy\ci\generic.
Integration is done via return codes:

Return code 0:: Testing passed, no issues found
Return code 1:: Testing failed, at least one issue found
Return code 100:: Testing did not complete due to an error

For more information about using the generic CI integration script, please see the readme file included
in the distribution folder and also the comments at the top of the python script.

=== Automated Test Integration

Peach has support for several automated test frameworks with more under development.
If your automation framework is not currently supported please let support@peachfuzzer.com know
so it can be added to our list and an interim solution found.

==== JUnit 4

XXX

==== pytest

Pytest integration is provided as a pytest plugin called "pytest-peach".
It's available in the SDK as "sdk\webproxy\testrunners\pytest-peach".
The plugin builds and installs via the command "python setup.py install".
The plugin is also available via pip "pip install pytest-peach".

For full information about installation and usage see the 'README.adoc' file available
in the distribution folder.

==== Other

XXX

=== Fault Detection

XXXX

=== Configuration

One or more routes can be configured for use with the Peach Fuzzing Web Proxy feature.
Each route contains several configuration parameters.
Route entries are matched in order.
It's recommended that a final route entry be included with a Route pattern of +*+ as a catch all.

Adding multiple routes allows different configurations based on matching a portion of the Path.
For example, if two different APIs are accessed during testing `/storage/*` and `/users/*`,
each can have a different route entry allowing for different fault status codes
or Swagger API specifications.

_Required:_

Path Pattern:: This pattern will match a specific route to a request.
Define a pattern that matches the HTTP request path (excluding the sheme, host, and query)
using single character wildcard (+?+) and multiple character wildcard (+*+). +
Examples: `/storage/*` or `*/v?/*`

_Optional:_

Test:: Should the route be included or excluded from testing.
This setting affects all requests that match the route.

Swagger:: Optionally provide the URL to a Swagger API JSON. +
For example, +http://127.0.0.1:8888/swagger/docs/v1+ or +file:///opt/service/swagger.js+

Script:: Optional path to a python script.  See xref:webproxy_Scripts[Scripts] for a full explanation and examples.

Rewrite Base URL:: Optionally provide a new replacement base URL.
Only the scheme, host, and port are replaced.

Failure Status Codes:: Optionally provide a comma separated list of HTTP status codes that
will result in a test failing. When a test fails it is logged as a fault in the tool. +
Example: +500,501+
Header Testing:: This parameter controls what HTTP headers are included/excluded from testing. +
+
Mutate;; Include or exclude the header from mutation.
Pattern;; Pattern to match against HTTP headers.
+
Headers support pattern matching using the single character wildcard (+?+) or multiple character wildcard (+*+). +


[[webproxy_Scripts]]
=== Scripts

The _Script_ configuration option allows custom code to be run after fuzzing but prior to sending outgoing HTTP requests.
This is typically used to implement custom authentication required by the target web service.
When the script is imported, it registers a function with the peach.webproxy python module.
The function will then be called with every outgoing request after all fuzzing has taken place.
This allows arbitrary changes to be made on a per request basis.
Headers can be added/removed and the body can be altered if needed.


.Sample AWS Authentication Script
========================
This example demonstrates how to set the +Authorization+ header in every outgoing request.

----
from peach import webproxy <1>

import base64
import hmac

from hashlib import sha1
from email.Utils import formatdate

AWS_ACCESS_KEY_ID = 'AWS_ACCESS_KEY_ID'
AWS_SECRET_KEY = 'AWS_SECRET_KEY'

def aws_auth(ctx, req, body): <2>
    XAmzDate = formatdate()

    hdrs = '%s\n\n%s\n\nx-amz-date:%s\n/?policy' % (req.method, req.contentType, XAmzDate)
    h = hmac.new(AWS_SECRET_KEY, hdrs, sha1)
    authToken = base64.encodestring(h.digest()).strip()

    req.headers['x-amz-date'] = XAmzDate
    req.headers['Authorization'] = 'AWS %s:%s' % (AWS_ACCESS_KEY_ID, authToken) <3>

webproxy.register_event(webproxy.EVENT_ACTION, aws_auth) <4>
----
<1> Import peach.webproxy module to register for events
<2> Function has three arguments: Context, Request, Body
<3> Set the header value
<4> Register function with Peach Web
========================

// end
