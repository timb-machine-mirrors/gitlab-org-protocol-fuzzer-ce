<<<
[[String]]
== String

// 01/30/2014: Seth & Mike: Outlined
//  * Verify all attributes
//  * Verify child elements
//  * Add mutators
//  * Discuss
//   * ASCII is latin-1 character set, not full 8 bit
//   * Unicode
//   * null termination (affect length?)
//   * with and without length (setting value != setting length)
//   * setting token == setting length
//   * numerical strings
//   * constraint not used in look a heads for unsized elements, only token can be
//   * Numerical string
//    * Relation ship on from size
//    * Hint no longer matters (automatically added/removed)
//    * Done every time default value is set (value=, slurp, etc.)
//   * Escaping special characters \t, \n, \r, \\
//  Examples:
//   * ASCII (show output)
//   * length with less content (pad, show output)
//   * String with size-of relation
//   * Numerical string
//   * Numerical string relation to another element (size-of, count-of, offset-of)
//   * token is case dependent, constraint doesn't have to be

// 03/07/2014: Lynn
//   * Added missing child elements and corrected spelling in comments

A string containing ASCII or Unicode character. Strings can be null terminated, padded, with or without a fixed length.

All strings are encoded prior to output with the default encoding 7-bit ASCII (aka Latin-1). A number of different Unicode encodings are also supported (see the _type_ attribute).

Strings are also used to hold numbers that will be in a string format. When strings contain a number, the numerical mutators will also be used to mutate the string.

=== Syntax

[source,xml]
----
<String value="Hello World!" />

<String value="Null terminated string" nullTerminated="true" />
----

=== Attributes

_Required:_

There are no required attributes.

_Optional:_

xref:name[name]:: Name of the string 

xref:length[length]:: Length in characters of the string
xref:lengthType[lengthType]:: Units of the length attribute (defaults to bytes)

type::
	Character encoding type, defaults to _ascii_. Valid options are: ASCII, utf7, utf8, utf16, utf16be, utf32.
	+
	When strings are outputted they are first encoded. The default encoding is 7-bit ASCII, also known as latin-1. Most common Unicode encodings are supported.

xref:value[value]:: The default value, defaults to _Peach_.
xref:valueType[valueType]:: Value attribute format, defaults to string.

nullTerminated::
	Is this string null terminated, defaults to false.
	+
	The _nullTerminated_ attribute indicates the produced string should be null terminated.
	It should be noted that only the final value will have the null termination applied, if the value is accessed the internal value will not have the null attached.
	+
	When _nullTerminated_ attribute is provided the xref:String[String] must not specify a xref:length[length] as they are mutually exclusive.

padCharacter::
	Character to pad string with to _length_, defaults to null (0x00).
	+
	If the _length_ attribute is provided but the value contained in the string is shorter than the length it will be padded.
	This attribute allows controlling the character used to pad the string.

xref:token[token]::
	This element should be treated as a token when parsing, defaults to false.
	+
	This attribute is primarily used to assist in cracking of strings when consuming input into a model.

xref:constraint[constraint]::
	A constraint in the form of a scripting expression that is used during data cracking.
	+
	This attribute is used typically in conjunction with the xref:Choice[Choice] element, or to control array expansion. It is only executed during data cracking.
	+
	NOTE: This expression will not control of affect mutated values in anyway.

xref:mutable[mutable]:: Is data element changeable? (should it be mutated?), defaults to false.

xref:minOccurs[minOccurs]:: The minimum number of times this block must occur, defaults to 1.
xref:maxOccurs[maxOccurs]:: The maximum number of times this block can occur, defaults to 1.
xref:occurs[occurs]:: Actual number of occurrences, defaults to 1.

=== Child Elements

xref:Analyzers[Analyzer]:: Attach an analyzer to this element
xref:Fixup[Fixup]:: Dynamic transformations such as checksums and CRCs.
xref:Hint[Hint]:: Provide information to mutators.
xref:Placement[Placement]:: Relocate an element after it has been cracked.
xref:Relation[Relation]:: Modeling of relationships in the data (such as comparisons)
xref:Transformer[Transformer]:: Static transformations such as compression or encoding.

=== Mutators

The following mutators will operate on this element type:


_Enabled when element is marked as an array_

xref:Mutators_ArrayNumericalEdgeCasesMutator[ArrayNumericalEdgeCasesMutator]:: This mutator will grow and shrink an array to counts based on numerical edge cases.
xref:Mutators_ArrayRandomizeOrderMutator[ArrayRandomizeOrderMutator]:: This mutator will randomize the order of items in an array.
xref:Mutators_ArrayReverseOrderMutator[ArrayReverseOrderMutator]:: This mutator will reverse the order of items in an array.
xref:Mutators_ArrayVarianceMutator[ArrayVarianceMutator]:: This mutator will grow and shrink an array to a variance of counts based on the current size.

_Used for all data elements_

xref:Mutators_DataElementBitFlipper[DataElementBitFlipper]:: This mutator will produce test cases by flipping bits in the output value.
xref:Mutators_DataElementDuplicate[DataElementDuplicate]:: This mutator will duplicate data elements.
xref:Mutators_DataElementRemove[DataElementRemove]:: This mutator will remove data elements.
xref:Mutators_DataElementSwapNear[DataElementSwapNear]:: This mutator will swap data elements.
xref:Mutators_SampleNinjaMutator[SampleNinjaMutator]:: This mutator will combine data elements from different data sets.

_Enabled when element is part of a size relation_

xref:Mutators_SizedDataEdgeCase[SizedDataEdgeCase]:: This mutator will cause the data portion of a relation to be sized as numerical edge cases.
xref:Mutators_SizedDataVariance[SizedDataVariance]:: This mutator will cause the data portion of a relation to be sized as numerical variances.
xref:Mutators_SizedEdgeCase[SizedEdgeCase]:: This mutator will change both sides of the relation (data and value) to match numerical edge cases.
xref:Mutators_SizedVariance[SizedVariance]:: This mutator will change both sides of the relation (data and value) to match numerical variances of the current size.

_Specific to this element type_

xref:Mutators_ExtraValues[ExtraValues]:: This mutator allows providing extra test case values on a per-data element basis.
xref:Mutators_StringAsciiRandom[StringAsciiRandom]:: This mutator will generate strings with random ASCII characters.
xref:Mutators_StringCaseLower[StringCaseLower]:: This mutator will generate a lower case version of the current value.
xref:Mutators_StringCaseRandom[StringCaseRandom]:: This mutator will generate a randomized case version of the current value.
xref:Mutators_StringCaseUpper[StringCaseUpper]:: This mutator will generate an upper case version of the current value.
xref:Mutators_StringLengthEdgeCase[StringLengthEdgeCase]:: This mutator will generate strings with lengths based on numerical edge cases.
xref:Mutators_StringLengthVariance[StringLengthVariance]:: This mutator will generate strings with lengths based on a variance around the current string length.
xref:Mutators_StringList[StringList]:: This mutator allows providing a list of strings to use as test cases on an element by element basis.
xref:Mutators_StringStatic[StringStatic]:: This mutator generates test cases using a static set of strings.
xref:Mutators_StringUnicodeAbstractCharacters[StringUnicodeAbstractCharacters]:: This mutator generates Unicode strings using abstract characters.
xref:Mutators_StringUnicodeFormatCharacters[StringUnicodeFormatCharacters]:: This mutator generates Unicode strings using format characters.
xref:Mutators_StringUnicodeInvalid[StringUnicodeInvalid]:: This mutator generates Unicode strings using invalid characters.
xref:Mutators_StringUnicodeNonCharacters[StringUnicodeNonCharacters]:: This mutator generates Unicode strings using non-characters.
xref:Mutators_StringUnicodePlane0[StringUnicodePlane0]:: This mutator generates Unicode strings using Plane 0 characters.
xref:Mutators_StringUnicodePlane1[StringUnicodePlane1]:: This mutator generates Unicode strings using Plane 1 characters.
xref:Mutators_StringUnicodePlane14[StringUnicodePlane14]:: This mutator generates Unicode strings using Plan 14 characters.
xref:Mutators_StringUnicodePlane15And16[StringUnicodePlane15And16]:: This mutator generates Unicode strings using Plane 15 and 16 characters.
xref:Mutators_StringUnicodePlane2[StringUnicodePlane2]:: This mutator generates Unicode strings using Plane 2 characters.
xref:Mutators_StringUnicodePrivateUseArea[StringUnicodePrivateUseArea]:: This mutator generates Unicode characters from the private use area.
xref:Mutators_StringXmlW3C[StringXmlW3C]:: This mutator provides the W3C XML parser unit tests. Must be specifically enabled.


=== Examples

.Simple ASCII String
====================

This example will output a string with the default options. The string will consist of 7-bit ASCII characters.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

	<DataModel name="TheDataModel">
		<String value="Hello World!" />
	</DataModel>

	<StateModel name="TheStateModel" initialState="InitialState" >
		<State name="InitialState">
			<Action type="output">
				<DataModel ref="TheDataModel"/>
			</Action>
		</State>
	</StateModel>

	<Test name="Default">
		<StateModel ref="TheStateModel"/>

		<Publisher class="ConsoleHex" />

		<Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
	</Test>
</Peach>
----

Produces the following output:

----
> peach -1 --debug example.xml

[[ Peach Pro v3.0.0
[[ Copyright (c) Deja vu Security

[*] Test 'Default' starting with random seed 25723.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(12 bytes)
00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21               Hello World!
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.
----
====================

.String with UTF-16 Encoding
====================

This example will output a string consisting of characters represented with the Unicode UTF-16 encoding. UTF-16 is a two-byte character encoding that supports latin and non-latin character sets. Also, UTF-16 is the WCHAR type on the Windows operating systems.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

	<DataModel name="TheDataModel">
		<String type="utf16" value="Hello World!" />
	</DataModel>

	<StateModel name="TheStateModel" initialState="InitialState" >
		<State name="InitialState">
			<Action type="output">
				<DataModel ref="TheDataModel"/>
			</Action>
		</State>
	</StateModel>

	<Test name="Default">
		<StateModel ref="TheStateModel"/>

		<Publisher class="ConsoleHex" />

		<Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
	</Test>
</Peach>
----

Produces the following output:

----
> peach -1 --debug example.xml

[[ Peach Pro v3.0.0
[[ Copyright (c) Deja vu Security

[*] Test 'Default' starting with random seed 57920.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(24 bytes)
00000000   48 00 65 00 6C 00 6C 00  6F 00 20 00 57 00 6F 00   H?e?l?l?o? ?W?o?
00000010   72 00 6C 00 64 00 21 00                            r?l?d?!?
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.
----
====================

.Null Terminated String
====================

This example will output a string with null termination.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

	<DataModel name="TheDataModel">
		<String nullTerminated="true" value="Hello World!" />
	</DataModel>

	<StateModel name="TheStateModel" initialState="InitialState" >
		<State name="InitialState">
			<Action type="output">
				<DataModel ref="TheDataModel"/>
			</Action>
		</State>
	</StateModel>

	<Test name="Default">
		<StateModel ref="TheStateModel"/>

		<Publisher class="ConsoleHex" />

		<Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
	</Test>
</Peach>
----

Produces the following output:

----
> peach -1 --debug example.xml

[[ Peach Pro v3.0.0
[[ Copyright (c) Deja vu Security

[*] Test 'Default' starting with random seed 53517.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(13 bytes)
00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21 00            Hello World!?
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.
----
====================

.String Padded with Default Character
====================

This example will output a string that is shorter than the required length. The string will receive one or more pad characters to reach its required length. The default pad character is null (0x00).

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

	<DataModel name="TheDataModel">
		<String length="20" value="Hello World!" />
	</DataModel>

	<StateModel name="TheStateModel" initialState="InitialState" >
		<State name="InitialState">
			<Action type="output">
				<DataModel ref="TheDataModel"/>
			</Action>
		</State>
	</StateModel>

	<Test name="Default">
		<StateModel ref="TheStateModel"/>

		<Publisher class="ConsoleHex" />

		<Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
	</Test>
</Peach>
----

Produces the following output:

----
> peach -1 --debug example.xml

[[ Peach Pro v3.0.0
[[ Copyright (c) Deja vu Security

[*] Test 'Default' starting with random seed 43832.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(20 bytes)
00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21 00 00 00 00   Hello World!????
00000010   00 00 00 00                                        ????
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.
----
====================

.String Padded with Specified Character
====================

This example will output a string that is shorter than the required length. The string will receive one or more pad characters to reach its required length. Unlike the earlier example, we will define the pad character as '_', thus overriding the default pad character.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

	<DataModel name="TheDataModel">
		<String length="20" padCharacter="_" value="Hello World!" />
	</DataModel>

	<StateModel name="TheStateModel" initialState="InitialState" >
		<State name="InitialState">
			<Action type="output">
				<DataModel ref="TheDataModel"/>
			</Action>
		</State>
	</StateModel>

	<Test name="Default">
		<StateModel ref="TheStateModel"/>

		<Publisher class="ConsoleHex" />

		<Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
	</Test>
</Peach>
----

Produces the following output:

----
> peach -1 --debug example.xml

[[ Peach Pro v3.0.0
[[ Copyright (c) Deja vu Security

[*] Test 'Default' starting with random seed 62597.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(20 bytes)
00000000   48 65 6C 6C 6F 20 57 6F  72 6C 64 21 5F 5F 5F 5F   Hello World!____
00000010   5F 5F 5F 5F                                        ____
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.
----
====================

.String with Backslash Characters
====================

This example will output a string that contains carriage return and line feed characters using the +\r+ and +\n+ notation. Also, the output string will  include a backslash character (+\+).

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

	<DataModel name="TheDataModel">
		<String value="This is the first line\nAnd this is the second line\n\rThis is backslash \\." />
	</DataModel>

	<StateModel name="TheStateModel" initialState="InitialState" >
		<State name="InitialState">
			<Action type="output">
				<DataModel ref="TheDataModel"/>
			</Action>
		</State>
	</StateModel>

	<Test name="Default">
		<StateModel ref="TheStateModel"/>

		<Publisher class="Console" />

		<Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
	</Test>
</Peach>
----

Produces the following output:

----
> peach -1 --debug example.xml

[[ Peach Pro v3.0.0
[[ Copyright (c) Deja vu Security

[*] Test 'Default' starting with random seed 29966.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(72 bytes)
This is the first line
And this is the second line
This is backslash \.Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.
----
====================

.String with Size-Of Relation
====================

In this example we use a String element to contain the ASCII length of some data. A size-of relation is used to allow the size to dynamically update during fuzzing.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

	<DataModel name="TheDataModel">
		<String name="Length">
			<Relation type="size" of="Data" />
		</String>

		<String value="\n" />

		<Block name="Data">
			<String value="This is some data!" />
			<String value=" And this is even more data!" />
		</Block>
	</DataModel>

	<StateModel name="TheStateModel" initialState="InitialState" >
		<State name="InitialState">
			<Action type="output">
				<DataModel ref="TheDataModel"/>
			</Action>
		</State>
	</StateModel>

	<Test name="Default">
		<StateModel ref="TheStateModel"/>

		<Publisher class="Console" />

		<Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
	</Test>
</Peach>
----

Produces the following output:

----
> peach -1 --debug example.xml

[[ Peach Pro v3.0.0
[[ Copyright (c) Deja vu Security

[*] Test 'Default' starting with random seed 2887.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(49 bytes)
46
This is some data! And this is even more data!Peach.Core.Publishers.ConsolePubli
sher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.
----
====================

.Using token Attribute to Crack Strings
====================
In this example we will parse a simple text string using the _token_ attribute. This example uses two files, a file containing sample data called +string.txt+ and the pit file +example.xml+. The sample string we are going to parse consists of three parts: 1) the key, 2) the token separator, and 3) a value. Potentially, the key and value can be any arbitrary size, so cracking this sample string requires knowledge about the token separator. In our pit file, we will mark our token string with the _token_ attribute to indicate that the token must be present in the incoming data stream. This will allow the data cracker to figure out the length of both key and value.

Peach will still fuzz elements marked as _token_.

.string.txt
----
Content-length: 10
----

[source,xml]
.example.xml
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

	<DataModel name="TheDataModel">
		<String name="Key"/>

		<String value=":" token="true" />

		<String name="Value"/>
	</DataModel>

	<StateModel name="TheStateModel" initialState="InitialState" >
		<State name="InitialState">
			<Action type="output">
				<DataModel ref="TheDataModel"/>
				<Data fileName="string.txt" />
			</Action>
		</State>
	</StateModel>

	<Test name="Default">
		<StateModel ref="TheStateModel"/>

		<Publisher class="Console" />

		<Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
	</Test>
</Peach>
----

Produces the following output:

----
> peach -1 --debug example.xml

[[ Peach Pro v3.0.0
[[ Copyright (c) Deja vu Security

[*] Test 'Default' starting with random seed 18622.

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker DataModel 'TheDataModel' Bytes: 0/21, Bits: 0/168

Peach.Core.Cracker.DataCracker getSize: -----> DataModel 'TheDataModel'
Peach.Core.Cracker.DataCracker scan: DataModel 'TheDataModel'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.Key' -> Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker getSize: <----- Deterministic: ???
Peach.Core.Cracker.DataCracker Crack: DataModel 'TheDataModel' Size: <null>, Bytes: 0/21, Bits: 0/168
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'TheDataModel.Key' Bytes: 0/21, Bits: 0/168
Peach.Core.Cracker.DataCracker getSize: -----> String 'TheDataModel.Key'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.Key' -> Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'TheDataModel.Key'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.DataElement_0' -> Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.DataElement_0' -> Pos: 8, Length: 8
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.Value' -> Offset: 8, Unsized element
Peach.Core.Cracker.DataCracker getSize: <----- Required Token: 112
Peach.Core.Cracker.DataCracker Crack: String 'TheDataModel.Key' Size: 112, Bytes: 0/21, Bits: 0/168
Peach.Core.Dom.DataElement String 'TheDataModel.Key' value is: Content-length <1>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'TheDataModel.DataElement_0' Bytes: 14/21, Bits: 112/168
Peach.Core.Cracker.DataCracker getSize: -----> String 'TheDataModel.DataElement_0'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.DataElement_0' -> Pos: 0, Saving Token
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.DataElement_0' -> Pos: 8, Length: 8
Peach.Core.Cracker.DataCracker getSize: <----- Size: 8
Peach.Core.Cracker.DataCracker Crack: String 'TheDataModel.DataElement_0' Size:8, Bytes: 14/21, Bits: 112/168
Peach.Core.Dom.DataElement String 'TheDataModel.DataElement_0' value is: : <2>
Peach.Core.Cracker.DataCracker ------------------------------------
Peach.Core.Cracker.DataCracker String 'TheDataModel.Value' Bytes: 15/21, Bits: 120/168
Peach.Core.Cracker.DataCracker getSize: -----> String 'TheDataModel.Value'
Peach.Core.Cracker.DataCracker scan: String 'TheDataModel.Value' -> Offset: 0, Unsized element
Peach.Core.Cracker.DataCracker lookahead: String 'TheDataModel.Value'
Peach.Core.Cracker.DataCracker getSize: <----- Last Unsized: 48
Peach.Core.Cracker.DataCracker Crack: String 'TheDataModel.Value' Size: 48, Bytes: 15/21, Bits: 120/168
Peach.Core.Dom.DataElement String 'TheDataModel.Value' value is:  10 <3>

Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(21 bytes)
Content-length: 10
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()

[*] Test 'Default' finished.
----
<1> Cracking "Content-length" into _Key_
<2> Cracking ":" into token string
<3> Cracking "10\n" into _Value_
====================
