<<<
[[Choice]]
== Choice

// Reviewed:
//  - 03/06/2014: Lynn
//   Added and edited child elements

The Choice element is a child element of xref:DataModel[DataModel] or xref:Block[Block].  Choice elements are expected to have valid sub-elements; Peach will select a sub-element to fuzz.  

Choice elements act like a switch statement in programming languages.

=== Syntax

[source,xml]
----
<Choice name="ChoiceBlock">
  <Block name="Type1">
    <!-- ... -->
  </Block>
  <Block name="Type2">
    <!-- ... -->
  </Block>
  <Block name="Type3">
    <!-- ... -->
  </Block>
</Choice>
----

=== Attributes

_Required:_

There are no required attributes.

_Optional:_

xref:name[name]:: Name of the choice section.
xref:length[length]:: Data element length
xref:lengthType[lengthType]:: Length attribute unit. Defaults to bytes.
xref:mutable[mutable]:: Element mutability. Defaults to false.
xref:constraint[constraint]:: Scripting expression that evaluates to true or false. Defaults to null.
xref:minOccurs[minOccurs]:: The minimum number of times this choice must occur. 
xref:maxOccurs[maxOccurs]:: The maximum number of times this choice can occur. 
xref:occurs[occurs]:: The number of times this choice can occur.

=== Child Elements

xref:Analyzers[Analyzer]:: Analyze current element post cracking, can dynamically change model.
xref:Blob[Blob]:: Used to represent binary data (think array of bytes) to create simple dumb fuzzers in Peach.
xref:Block[Block]:: Group one or more data elements together into a logical structure.  
xref:Choice[Choice]:: Indicate any of the sub-elements are valid but only one should be selected.
xref:Fixup[Fixup]:: Dynamic transformations such as checksums and CRCs.
xref:Flags[Flags]:: Defines a set of bit sized flags.
xref:Hint[Hint]:: Provide information to mutators.
xref:Number[Number]:: Defines a binary number of lengths 8, 16, 24, 32, or 64 bits.
xref:Padding[Padding]:: Pad out variably sized blocks or data models.
xref:Placement[Placement]:: Relocate an element after it has been cracked.
xref:Transformer[Transformer]:: Static transformations such as compression or encoding. 
xref:XmlElement[XmlElement]:: Defines an XML element, the basic building block of XML documents. 

=== Mutators

The following mutators will operate on this element type:

xref:Mutators_DataElementDuplicateMutator[DataElementDuplicateMutator]:: Duplicates a node's value from 2x - 50x
xref:Mutators_DataElementRemoveMutator[DataElementRemoveMutator]:: Removes nodes from the data model
xref:Mutators_DataElementSwapNearNodesMutator[DataElementSwapNearNodesMutator]:: Swaps two nodes in the data model that are neighboring each other
 
=== Examples

.Basic Example
==========================
A basic Choice block. This choice example will crack or consume data of type 1,2,3. Much like a regular switch statement a decision needs to be made on a token. 

If the first 8 bits are 1 then the remaining data is treated as a 32 bit number. 
If the first 8 bits are 2 then the remaining data is treated as a 255 bytes of binary data. 
If the first 8 bits are 3 then the remaining data is treated as a 8 byte string. 

When fuzzing Peach will chose one of the three types and fuzz it's output as an 8bit number followed by the corresponding type. Peach will attempt to full all three types.  

[source,xml]
----
<DataModel name="ChoiceExample1">
 <Choice name="Choice1">

  <Block name="Type1">
    <Number name="Str1" size="8" value="1" token="true" />
    <Number size="32"/>
  </Block>

  <Block name="Type2">
    <Number name="Str2" size="8" value="2" token="true" />
    <Blob length="255" /> 
  </Block>

  <Block name="Type3">
    <Number name="Str3" size="8" value="3" token="true" />
    <String length="8" />
  </Block>
 </Choice>
</DataModel>
----
==========================

.An Array of Choices
==========================
The first example is good for making a single choice but what if there are many Type1 Type2 and Type3 blocks all following each other? Set minOccurs, maxOccurs, or occurs to specify the choice should be repeated. 


This example attempts to crack at least 3 different choices and no more than 6. 

[source,xml]
----
<DataModel name="ChoiceExample1">
 <Choice name="Choice1" minOccurs="3" maxOccurs="6">

  <Block name="Type1">
    <Number name="Str1" size="8" value="1" token="true" />
    <Number size="32"/>
  </Block>

  <Block name="Type2">
    <Number name="Str2" size="8" value="2" token="true" />
    <Blob length="255" /> 
  </Block>

  <Block name="Type3">
    <Number name="Str3" size="8" value="3" token="true" />
    <String length="8" />
  </Block>
 </Choice>
</DataModel>
----
==========================
