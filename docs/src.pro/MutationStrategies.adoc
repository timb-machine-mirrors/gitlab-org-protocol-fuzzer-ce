[[MutationStrategies]]
== Pluggable Mutation Strategies

// Reviewed:
//  - 01/30/2014: Seth & Mike: Outlined

// * How/when we choose mutators and use them
// * How/when we select data set
// * Can implement your own
// * Seeds impact strategy
// * finite vs. infinite
// * selecting
// * Examples
// * Order of fuzzing
// * Default strategy is Random
// * Add replay strategy
// * Passing parameters
// * Complicated state model with early exit will cause nothing to get fuzzed (maybe in booky part)
// * Mutators get random numbers from strategies


Peach has pluggable mutation strategies to deal with two common situations: 

* Peach usually fuzzes DataModels using a top-down, sequential method.  While this guarantees that every data element will get fuzzed with each test case, this may not be the best solution for larger, complex systems which can produce millions of test case variations.  

* Peach needs a mechanism to allow you to easily change how fuzzing is performed. This helps you determine the best fuzzing methods and strategies for your situation.

If you implement a single single C# class, you can fully control how Peach fuzzes a target (including state transitions) because:

* The C# class has full control over data mutations and state transition mutations.
* Data mutations are changing the value of a data element
* State mutations are if the pit says we should transition to state named "RxPacket1" but the mutation strategy can change this so peach transitions to the state named "TxPacket4" instead.


Peach supplies three user-extensible mutation strategies:

* Random (default)
* Sequential
* RandomDeterministic

=== Random 

Random is the default fuzzing strategy.  

This strategy will select up to _MaxFieldsToMutate_ elements to mutate at a time.  For each selected element one of it's corresponding mutators is selected at random. Peach derives the randomness of these selections from randomly generated seed number. An identical test run can be repeated by passing the same *seed* value as a Peach command line option with the _--seed_ command line option.  This is useful for replaying fuzzing iterations to reproduce a previous Fault.

This strategy is most useful for larger data models or for use after performing a sequential fuzzing run.

IMPORTANT: The random strategy can have an infinite number of fuzzing iterations; it can run forever. 


==== Parameters

MaxFieldsToMutate:: Maximum fields to mutate at once. default="6"
SwitchCount:: Number of iterations to perform before switching xref:Data[Data] sets. default="200"

*Examples*

[source,xml]
----
<Test name="Default">
	<StateModel ref="TheStateModel"/>
    
	<Publisher name="writer" class="File">
		<Param name="FileName" value="fuzzed.tmp"/>
	</Publisher>

	<Strategy class="Random">
		<Param name="MaxFieldsToMutate" value="15" />
		<Param name="SwitchCount" value="100" />
	</Strategy>
</Test>
----

=== Sequential

If you select the sequential strategy, Peach will fuzz each element in the DataModel in order, one at a time. Peach will start from the top of the DataModel and apply all valid mutation to each data element until all possible mutations have been exhausted.  

The sequential strategy has a finite number of fuzzing iterations.  

TIP: The seed for this strategy is not configurable and is always 31337.

==== Examples

[source,xml]
----
<Test name="Default">
  <!-- ... -->
  <Strategy class="Sequential" />
</Test>
----

=== RandomDeterministic

This fuzzing strategy is deterministic (has a start and end).  It is similar to the Sequential strategy except the order of mutations has been shuffled. There is still a finite number of iterations and if run to completion will run every iteration that is generation with the Sequential strategy.  Similarly to the Random strategy the seed value can be used to repeat a previous test run with identical fuzzing.
