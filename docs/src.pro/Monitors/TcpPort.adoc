<<<
[[Monitors_TcpPort]]
== TcpPort Monitor

The _TcpPort_ monitor detects state changes on TCP ports. A state change is a transition in port status from Open to Closed or from Closed to Open. The _TcpPort_ monitor can be configured in the following ways:

* as an automation task (wait until a specified state occurs)
* fault detection (fault on a specific state)
* data collection (report the current state) 

The monitor includes an event trigger (the _When_ parameter) that you can use to control when automation occurs.

=== Parameters

_Required:_

Host:: Hostname or IP address of the remote host
Port:: Port number to monitor

_Optional:_

Action::
+
Action to take (Automation, Data, Fault). Defaults to _Automation_.
+
[horizontal]
Automation;; Wait for the port to reach a specified state. The _When_ parameter determines when the monitor waits. The maximum waiting time can be configured by setting the _Timeout_ parameter.
Data;; On a fault, report the state of fault at end of the current iteration.
Fault;; At end of the current iteration, generate a fault if the port is in a specified state.

When::
+
Event that specifies when to perform monitoring. The default setting is _OnCall_. The following settings are defined:
+
[horizontal]
OnCall;; Monitoring begins upon receipt of a message from the state machine.
OnStart;; Monitoring occurs once at the start of the fuzzing session.
OnEnd;; Monitoring occurs once at the end of the fuzzing session.
OnIterationStart;; Monitoring occurs at the start of each iteration.
OnIterationEnd;; Monitoring occurs at the end of each iteration.
OnFault;; Monitoring occurs immediately following a fault.
OnIterationStartAfterFault;; Monitoring occurs following a fault. Note that after the fault occurs, the current iteration completes. Then, at the start of the next iteration, monitoring begins.

WaitOnCall:: Call message to start monitoring. This parameter only applies to the _OnCall_ setting.

State:: 
+
Port state to monitor. The default value is _Open_.
+
[horizontal]
Open;; The port is available for use.
Closed;; The port is not available.

Timeout:: Length of time to wait for an incoming connection to be established. Specify values in milliseconds, or specify -1 to not use a timeout interval. 

=== Examples

.Wait for the port to be open
===============================
In this example, the call action causes Peach to wait until the remote port is in an open state. No timeout interval is provided, so Peach will wait forever.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

  <DataModel name="TheDataModel">
    <Number size="32" signed="false" value="31337" />
  </DataModel>

  <StateModel name="State" initialState="Initial" >
    <State name="Initial">
      <Action type="output">
          <DataModel ref="TheDataModel"/>
      </Action>
      
      <Action type="call" method="WaitForPort" publisher="Peach.Agent" />
    </State>
  </StateModel>

  <Agent name="Local">
	<Monitor class="TcpPort">
        <Param name="Host" value="192.168.133.4" />
        <Param name="Port" value="502" />
        <Param name="WaitOnCall" value="WaitForPort" />
	</Monitor>
  </Agent>


  <Test name="Default">
    <StateModel ref="State"/>

    <Agent ref="Local" />

    <Publisher class="ConsoleHex"/>

    <Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
  </Test>
</Peach>
----

===============================

.Wait for the port to be closed
===============================
In this example, the call action causes Peach to wait until the remote port is in a closed state. Since no timeout is provided, Peach will wait forever.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

  <DataModel name="TheDataModel">
    <Number size="32" signed="false" value="31337" />
  </DataModel>

  <StateModel name="State" initialState="Initial" >
    <State name="Initial">
      <Action type="output">
          <DataModel ref="TheDataModel"/>
      </Action>
      
      <Action type="call" method="WaitForPort" publisher="Peach.Agent" />
    </State>
  </StateModel>

  <Agent name="Local">
	<Monitor class="TcpPort">
        <Param name="Host" value="192.168.133.4" />
        <Param name="Port" value="502" />
        <Param name="State" value="Closed" />
        <Param name="WaitOnCall" value="WaitForPort" />
	</Monitor>
  </Agent>


  <Test name="Default">
    <StateModel ref="State"/>

    <Agent ref="Local" />

    <Publisher class="ConsoleHex"/>

    <Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
  </Test>
</Peach>
----


===============================

.Fault if the port closed
===============================
In this example, Peach faults if the port is in the closed state at the end of an iteration.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

  <DataModel name="TheDataModel">
    <Number size="32" signed="false" value="31337" />
  </DataModel>

  <StateModel name="State" initialState="Initial" >
    <State name="Initial">
      <Action type="output">
          <DataModel ref="TheDataModel"/>
      </Action>
    </State>
  </StateModel>

  <Agent name="Local">
	<Monitor class="TcpPort">
        <Param name="Host" value="192.168.133.4" />
        <Param name="Port" value="502" />
        <Param name="Action" value="Fault" />
        <Param name="State" value="Closed" />
	</Monitor>
  </Agent>


  <Test name="Default">
    <StateModel ref="State"/>

    <Agent ref="Local" />

    <Publisher class="ConsoleHex"/>

    <Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
  </Test>
</Peach>
----



===============================

.Report the port state on fault
===============================
In this example, if a fault is triggered by another monitor, the TcpPort monitor reports the state of the port when the fault occurred.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

  <DataModel name="TheDataModel">
    <Number size="32" signed="false" value="31337" />
  </DataModel>

  <StateModel name="State" initialState="Initial" >
    <State name="Initial">
      <Action type="output">
          <DataModel ref="TheDataModel"/>
      </Action>
    </State>
  </StateModel>

  <Agent name="Local">
    <!-- Fault detection -->
    <Monitor class="LinuxDebugger">
      <Param name="Executable" value="/usr/bin/curl"/>
      <Param name="Arguments" value="http://localhost"/>
      <Param name="StartOnCall" value="ScoobySnacks"/>
    </Monitor>

    <!-- Data collection -->
	<Monitor class="TcpPort">
        <Param name="Host" value="192.168.133.4" />
        <Param name="Port" value="502" />
        <Param name="Action" value="Data" />
	</Monitor>
  </Agent>


  <Test name="Default">
    <StateModel ref="State"/>

    <Agent ref="Local" />

    <Publisher class="ConsoleHex"/>

    <Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
  </Test>
</Peach>
----

===============================
