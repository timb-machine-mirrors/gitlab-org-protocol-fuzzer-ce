<<<
[[Monitors_SshCommand]]
== SshCommand Monitor

The _SshCommand_ monitor connects to a remote host over SSH (Secure Shell) and waits for its exit.
The output from the process is logged when a fault is detected.
This monitor can operate as a fault detector, data collector, and automation module depending on configuration.
All major forms of SSH authentication are supported.

To increase the speed of operation, the monitor holds open the SSH connection to the remote machine.
This removes the cost of authenticating every time the command is executed.
If multiple _SshCommand_ monitors are configured against the same remote host, multiple SSH connections are created and held open.

*Fault Detection*

This monitor can perform fault detection by matching output from the executed command with a regular expression.
To configure this monitor to perform fault detection, set the +FaultOnMatch+ parameter to +true+ (this is the default), then provide a regular expression
to match the +CheckValue+ parameter.

*Data Collection*

The monitor always collects the output from the executed command and reports it for logging when a fault is detected.

*Automation*

This monitor can run commands on remote machines to perform automation tasks.

=== Parameters

_Required:_

Host:: Remote Host for the SSH connection; the connection target.
Username:: Username for ssh.
Command:: Command to check for fault.

_Optional:_

Password:: Password for SSH account, defaults to "".
KeyPath:: Path to SSH key, defaults to "".
CheckValue:: Regex to match command response, defaults to "".
FaultOnMatch:: Trigger a fault if the regex matches, defaults to true.
When::
+
Period when the command should be run. Defaults to +OnCall+
+
[horizontal]
DetectFault;; Run command to check for faulting condition. Requires regex be set. Original and default mode of operation.
OnCall;; Trigger command to run from state model. Command runs when the _StartOnCall_ message is received.
OnStart;; Run command when fuzzing session starts. Command runs once per session.
OnEnd;; Run command when fuzzing session stops. Command runs run once per session.
OnIterationStart;; Run command at start of each iteration.
OnIterationEnd;; Run command at end of each iteration.
OnFault;; Run command when a fault occurs.
OnIterationStartAfterFault;; Run command at start of the iteration that follows a fault detection.

StartOnCall:: Run when signaled by the state machine.

=== Examples

.Checking for core dump files
==========
For this example we connect to the target machine using SSH at the end of each iteration to check if any core files exist. If no core files exist, a fault occurs.

To run this example, specify a valid Host, Username, and Password.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

  <DataModel name="TheDataModel">
    <Number size="32" signed="false" value="31337" />
  </DataModel>

  <StateModel name="State" initialState="Initial" >
    <State name="Initial">
      <Action type="output">
          <DataModel ref="TheDataModel"/>
      </Action>
    </State>
  </StateModel>

  <Agent name="Local">
    <Monitor class="Ssh">
      <Param name="Host" value="my.target.com" />
      <Param name="Username" value="tester" />
      <Param name="Password" value="Password!" />
      <Param name="Command" value="ls /var/cores/*.core" />
      <Param name="CheckValue" value="target.*?.core" />
      <Param name="FaultOnMatch" value="true" />
    </Monitor>
  </Agent>

  <Test name="Default">
    <StateModel ref="State"/>

    <Agent ref="Local" />

    <Publisher class="ConsoleHex"/>

    <Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
  </Test>
</Peach>
----

Output for this example.

----
>peach -1 --debug example.xml

[[ Peach Pro v3.0.0.0
[[ Copyright (c) Deja vu Security

[*] Test 'Default' starting with random seed 63850.
Peach.Core.Agent.Agent StartMonitor: Monitor Ssh
Peach.Core.Agent.Agent SessionStarting: Monitor

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   69 7A 00 00                                        iz??
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor

[*] Test 'Default' finished.
----

To verify that Peach is checking for a file on the remote machine, create a file named target.testing.core in /var/cores. When Peach logs in and finds that file, a fault occurs.

==========
