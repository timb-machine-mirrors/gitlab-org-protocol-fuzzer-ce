:images: ../images
<<<
[[Monitors_SshCommand]]
== SshCommand Monitor

*Monitor Categories*: *Automation*, *Data collection*, *Fault detection*

The _SshCommand_ monitor connects to a remote host over SSH (Secure Shell), runs a command, 
and waits for the command to complete. The output from the process is logged when a fault 
is detected. This monitor can operate as a fault detector, data collector, and automation 
module depending on configuration. All major forms of SSH authentication are supported.

To increase the speed of operation, the monitor holds open the SSH connection to the remote 
machine. This removes the cost of authenticating every time the command is executed. 
If multiple _SshCommand_ monitors are configured against the same remote host, multiple 
SSH connections are created and held open.

*Fault Detection*

This monitor can perform fault detection by matching output from the executed command with 
a regular expression. Set the +FaultOnMatch+ parameter to +true+ (this is the default and 
the original use of this monitor), then provide a regular expression to match the 
+CheckValue+ parameter to enable the fault detection.

*Data Collection*

The monitor always collects the output from the executed command and reports it for logging 
when a fault is detected.

*Automation*

This monitor can run commands on remote machines to perform automation tasks. Interesting points to wait during a fuzzing session include the following: 

* At the start or end of a fuzzing run
* At the start or end of each test iteration
* After detecting a fault
* At the start of an iteration that immediately follows a fault 
* When called from the StateModel

=== Parameters

_Required:_

Host:: Remote Host for the SSH connection; the connection target.
Username:: Username for ssh.
Command:: Command to check for fault.

_Optional:_

Password:: Password for SSH account, defaults to "".
KeyPath:: Path to SSH key, defaults to "".
CheckValue:: Regex to match the command response, defaults to "".

//FaultOnMatch:: Trigger a fault if the CheckValue regex matches, defaults to true.
FaultOnMatch:: Trigger a fault if the CheckValue regex matches, defaults to false. +
FaultOnMatch triggers a fault in a second case--when FaultOnMatch is false and Peach does not find a match for the CheckValue regex.

StartOnCall:: Run when signaled by the state machine.

When::
+
Period when the command should be run. Defaults to +DetectFault+.
+
// [horizontal]   - commented out because labels and descriptions overlap on some entries.
// DetectFault::: Run command to check for faulting condition. Requires regex be set. Original and default mode of operation.
// OnCall::: Trigger command to run from state model. Command runs when the _StartOnCall_ message is received.
// OnStart::: Run command when fuzzing session starts. Command runs once per session.
// OnEnd::: Run command when fuzzing session stops. Command runs run once per session.
// OnIterationStart::: Run command at start of each iteration.
// OnIterationEnd::: Run command at end of each iteration.
// OnFault::: Run command when a fault occurs.
// OnIterationStartAfterFault::: Run command at start of the iteration that follows a fault detection.
+
[cols="1,2" options="header",halign="center"] 
|==========================================================
|"When" Setting              |Description
|DetectFault                 |Run the command to check for the faulting condition. Requires a regex expression in the +CheckValue+ parameter. Default mode of operation.
|OnStart                     |Run the command when fuzzing session starts. Command runs once per session.
|OnEnd                       |Run the command when fuzzing session stops. Command runs run once per session.
|OnIterationStart            |Run the command at start of each iteration.
|OnIterationEnd              |Run the command at end of each iteration.
|OnFault                     |Run the command when Peach detects a fault.
|OnIterationStartAfterFault  |Run the command at start of an iteration that immediately follows a fault detection.
|OnCall                      |Trigger the command to run from the state model. The command runs when the _StartOnCall_ message is received.
|==========================================================
+
.When Choices for Running a Command
image::{images}/Timings_SSH.PNG["When Run Command Choices", scalewidth="75%"]

=== Examples

ifdef::peachug[]

.Check for core dump files +
====================

This parameter example is from a setup that connects to the target machine using SSH at the end of each iteration 
to check core files. If no core files exist, a fault occurs.

To run this example, specify a valid Host, Username, and Password.

[cols="2,4" options="header",halign="center"] 
|==========================================================
|Parameter     |Value
|Host          |my.target.com
|Username      |tester
|Password      |Password!
|Command       |ls /var/cores/*.core
|CheckValue    |target.*?.core
|FaultOnMatch  |true
|==========================================================
====================

endif::peachug[]


ifndef::peachug[]


.Checking for core dump files
==========
This example connects to the target Linux machine using SSH at the end of each iteration to check if any core files exist. If no core files exist, a fault occurs.

To run this example, specify a valid Host, Username, and Password.

[source,xml]
----
<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd">

  <DataModel name="TheDataModel">
    <Number size="32" signed="false" value="31337" />
  </DataModel>

  <StateModel name="State" initialState="Initial" >
    <State name="Initial">
      <Action type="output">
          <DataModel ref="TheDataModel"/>
      </Action>
    </State>
  </StateModel>

  <Agent name="Local">
    <Monitor class="Ssh">
      <Param name="Host" value="my.target.com" />
      <Param name="Username" value="tester" />
      <Param name="Password" value="Password!" />
      <Param name="Command" value="ls /var/cores/*.core" />
      <Param name="CheckValue" value="target.*?.core" />
      <Param name="FaultOnMatch" value="true" />
    </Monitor>
  </Agent>

  <Test name="Default">
    <StateModel ref="State"/>

    <Agent ref="Local" />

    <Publisher class="ConsoleHex"/>

    <Logger class="File">
      <Param name="Path" value="logs"/>
    </Logger>
  </Test>
</Peach>
----

Output for this example.

----
>peach -1 --debug example.xml

[[ Peach Pro v3.0.0.0
[[ Copyright (c) Peach Fuzzer LLC

[*] Test 'Default' starting with random seed 63850.
Peach.Core.Agent.Agent StartMonitor: Monitor Ssh
Peach.Core.Agent.Agent SessionStarting: Monitor

[R1,-,-] Performing iteration
Peach.Core.Engine runTest: Performing recording iteration.
Peach.Core.Dom.Action Run: Adding action to controlRecordingActionsExecuted
Peach.Core.Dom.Action ActionType.Output
Peach.Core.Publishers.ConsolePublisher start()
Peach.Core.Publishers.ConsolePublisher open()
Peach.Core.Publishers.ConsolePublisher output(4 bytes)
00000000   69 7A 00 00                                        iz??
Peach.Core.Publishers.ConsolePublisher close()
Peach.Core.Engine runTest: context.config.singleIteration == true
Peach.Core.Publishers.ConsolePublisher stop()
Peach.Core.Agent.Agent SessionFinished: Monitor

[*] Test 'Default' finished.
----

To verify that Peach is checking for a file on the remote machine, create a file named target.testing.core in /var/cores. When Peach logs in and finds that file, a fault occurs.

==========

endif::peachug[]
