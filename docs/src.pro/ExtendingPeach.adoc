[[Extending]]
== Extending Peach

// TODO - Analyzer
// TODO - Logger

{product} was designed to be extended, allowing the you to increase the capabilities of Peach in new ways. The most common reasons for extending Peach include: 
--
* Custom validation algorithms (such as checksums) 
* Custom publishers (I/O adapters), 
* Monitoring
--
Peach allows you to write custom agents, loggers, strategies, analyzers, and strategies. 

This section will cover the most common types of extensions to Peach.

<<<
[[Extend_Plugins]]
=== Peach Plugins

When using Peach with custom/proprietary targets it often required to extend the functionality of peach with plugins.

Peach is typically extended with custom implementations of Fixups, Transformers, Publishers and Monitors.
All extensions follow the same paradigm.  First, create a C# class that derives from the appropriate peach base class.
Second, decorate the class with the appropriate plugin attribute.
Finally, compile the class into an assembly and place the assembly in the Peach directory.
When Peach runs, it will automatically reflect all assemblies to get the list of Fixups, Transformers, Publishers and Monitors.

To see a list of all detected plugins and their parameters, run 'peach --showenv'.

=== Examples

.Fixup
==========================
This example shows the class definition for a custom fixup called "MyFixup".

[source,c#]
----
[Fixup("MyFixup", true)]
public class MyFixup : Peach.Core.Fixup
{
}
----

.Transformer
==========================
This example shows the class definition for a custom transformer called "MyTransformer".

[source,c#]
----
[Transformer("MyTransformer", true)]
public class MyTransformer : Peach.Core.Transformer
{
}
----

.Publisher
==========================
This example shows the class definition for a custom publisher called "MyPublisher".

[source,c#]
----
[Publisher("MyPublisher", true)]
public class MyPublisher : Peach.Core.Publisher
{
}
----

.Monitor
==========================
This example shows the class definition for a custom monitor called "MyMonitor".

[source,c#]
----
[Monitor("MyMonitor", true)]
public class MyMonitor : Peach.Core.Monitor
{
}
----

Peach plugins take a C# dictionary as a construction argument.
This argument dictionary is populated with the Param elements names and values defined in the Peach Pit.

This example shows the arguments in the JsEncode transformer constructor.

[source,c#]
----
[Transformer("JsEncode")]
public class JsEncode : Transformer
{
	public JsEncode(Dictionary<string, Variant> args)
		: base(args)
	{
	}
}
----

Peach plugins use ParameterAttribute to define all of their supported configuration arguments (name, type, description, and optional default value).

The name and type specified in the ParameterAttribute must match a public property on the plugin class.

If the name parameter happens to be a C# reserved keyword, prefix the associated class property with an underscore.

The default value is always provided as a string, regardless of the type of the parameter. If the default value is omitted from the ParameterAttribute, Peach treats the parameter as required.

This example shows the ParameterAttribute usage.

[source,c#]
----
[Transformer("MyTransformer")]
[Parameter("level", typeof(int), "Specifies the level, default: 9", "9")]
[Parameter("class", typeof(string), "Specifies the class, required!")]
public class MyTransformer : Transformer
{
	// Type matches typeof(int) in ParameterAttribute
	public int level { get; set; }

	// Name is '_class' since 'class' is a C# keyword
	public string _class { get; set; }

	public MyTransformer(Dictionary<string, Variant> args)
		: base(args)
	{
	}
}
----

ParameterParser.Parse() uses the arguments dictionary to automatically populate all plugin properties.

When populating the properties, type conversion is done to convert from the string specified in the pit to the concrete type defined in the plugin.
When performing automatic type conversion, the ParameterParser supports System.Enum as well as any type that implements IConvertable.

This method uses reflection to:

 * Enforce missing required parameters
 * Initialize optional parameters from default value
 * Type conversion from string to concrete type
 * Validation on all type conversion
 ** -100 is valid int
 ** -100 is not a valid byte

General Peach plugin best practices:

 * Use stream operations whenever possible
 * Avoid using large arrays of contiguous data
 * Validate parameter types in the plugin constructors
 * Provide useful error messages
 * Throw PeachException() when non-recoverable errors occur such as:
 ** Parameter is out of range
 ** User lacks appropriate permissions
 * Throw SoftException when recoverable errors occur such as:
 ** File in use
 ** Error starting process
 ** Socket connection refused

<<<
[[Extend_Fixup]]
=== Fixup

Fixups compute a value based on other elements.  Because of this, fixups have to track
whenever a referenced element changes and recompute their value.
For example, the Crc32 fixup needs to know whenever the referenced element changes so that
a new crc can be computed.
To accomplish this, all fixup implementations must tell the base Fixup class what
parameters are to be treated as references to other data elements.
Fixup implementations accomplish this by passing the names of their data element reference parameters as arguments to the base class constructor.

This is an example of a fixup with a single data element reference.

[source,c#]
----
[Fixup("CustomFixupOne", true)]
[Parameter("ref", typeof(string), "Reference to data element")]
[Serializable]
public class CustomFixupOne : Fixup
{
	public CustomFixupThree(DataElement parent, Dictionary<string, Variant> args)
		: base(parent, args, "ref")
	{
	}
}
----

This is an example of a fixup with three data element references.

[source,c#]
----
[Fixup("CustomFixupThree", true)]
[Parameter("refOne", typeof(string), "Reference to first data element")]
[Parameter("refTwo", typeof(string), "Reference to second data element")]
[Parameter("refThree", typeof(string), "Reference to third data element")]
[Serializable]
public class CustomFixupThree : Fixup
{
	public CustomFixupThree(DataElement parent, Dictionary<string, Variant> args)
		: base(parent, args, "refOne", "refTwo", "refThree")
	{
	}
}
----

Each fixup implementation needs to implement a single function: fixupImpl().
This function returns the result of the fixup computation.
It is important to maintain proper typing information when returning results from a fixup.
If the fixup evaluates to an integer, an int type should be returned.  Similarly,
if the fixup evaluates to a string, a string type should be returned.
This allows Peach to perform proper byte encoding when creating the final value for a data element.
Because the Crc fixup returns its value in an unsigned integer type, Peach will output
the bytes in the endianness defined on the parent data element.

Inside of fixupImpl(), the resolved data element references are obtained through the dictionary 'this.elements'.
The key to this dictionary is the name of the parameter (eg: 'ref') and the value is the appropriate data element.

This is an example of the fixupImpl function of a Crc fixup.

[source,c#]
----
protected override Variant fixupImpl()
{
	// Get the element we need to compute the crc of
	var elem = this.elements["ref"];
	// Get the stream of data for the target element
	var data = elem.Value;

	// Ensure we are at the beginning of the data
	data.Seek(0, System.IO.SeekOrigin.Begin);

	// Initialize the CRCTool
	CRCTool crcTool = new CRCTool();
	crcTool.Init(CRCTool.CRCCode.CRC32);

	// Return the crc of data as a uint
	return new Variant((uint)crcTool.crctablefast(data));
}
----

<<<
[[Extend_Monitor]]
=== Monitor

Custom monitors must implement the following functions:

 * StopMonitor()
 * SessionStarting()
 * SessionFinished()
 * IterationStarting()
 * IterationFinished()
 * DetectedFault()
 * GetMonitorData()
 * MustStop()
 * Message()

The SessionStarting and SessionFinished functions are called once per fuzzing session.
These functions are responsible for any initialization and cleanup required by the monitor.
Monitors can run remotely and there can be multiple monitors in a Peach pit.
It is possible that calling SessionStarting on the first monitor
triggers some behavior on the target that allows subsequent monitors to be able to start without erroring.
This means things like parameter validation and initialization should occur in the SessionStarting function
as opposed to the monitor's constructor.

The IterationStarting and IterationFinished functions are called once per fuzzing iteration.
All per-iteration logic is implemented in these functions.
Monitors that perform per-iteration process control will start and stop the target process in these functions.
Most importantly, any per-iteration state must be reset in calls to IterationFinished().
The current fuzzing iteration is driven by the Peach engine, and monitors must not use past iterations to make any
assumptions about future iterations.

The Message function is used to signal monitors at specific places in the StateModel execution.
This functionality is primarily used for state synchronization.
It allows the monitor to pause the execution of the StateModel at a specific point until some desired event happens.
For example, a custom monitor could use the Message function to wait until a proprietary embedded device
has rebooted and is ready to accept input data.
It is important to note that call actions on the "Peach.Agent" publisher results in the Message function
being called on every monitor.
Each monitor must filter for their desired messages, ignoring all unexpected message calls by returning null.

The DetectedFault and GetMonitorData functions are used to report faults back to Peach.
At the end of each iteration the Peach engine calls DetectedFault() on every monitor.
If any one monitor reports that a fault occurred, Peach calls GetMonitorData() on every monitor.
The GetMonitorData function returns a Fault record, and the type of the record can be either Fault or Data.

Fault Detection:

 * Return true from DetectedFault()
 * If any ONE monitor detects a fault, ALL monitors get called to return monitor data
 * GetMonitorData() returns applicable data
 * Returned fault can be +fault+ or +data+
 ** Debugger stack trace is +fault+
 ** Pcap is +data+
 * Faults can include hash for bucketing information

Monitor best practices:

 * Indicate errors with SoftExceptions()
 * Keep monitors simple
 * Prefer multiple small monitors
 * Agent/Monitor order in pit is honored by Peach
 ** Starting functions are called in order
 ** Finished functions are called in reverse order
 * Avoid one large complicated monitor
 * Remember monitors can run in remote agents
 * Maintain cross platform compatibility
 ** Windows Peach with Linux Agent

<<<
[[Extend_Publisher]]
=== Publisher

Publishers need to be extended whenever Peach needs to send or receive data through a custom IO channel.
Publishers support both a 'stream' view (open, input, output, close) and a 'function' view (call, setProperty, getProperty).
Each publisher method corresponds to a single action type used in the StateModel.
While publishers can support all action types, most do not need to.  For example, the File publisher does not
implement call, accept, setProperty and getProperty.
It is up to the developer to implement the functions that are appropriate.

All of the publisher's public functions are implemented in the base class.
The public functions ensure the publisher is in the proper state and if needed
call the protected implementation functions.  For example, the public open function
calls the protected OnOpen function only when the publisher is not already opened.
When developers implement custom publishers they override the protected functions.
The default implementation of these protected functions is to throw a NotImplementedException().

The list of user overridable functions are:

 * OnStart()
 * OnStop()
 * OnOpen()
 * OnClose()
 * OnAccept()
 * OnInput()
 * OnOutput()
 * OnCall()
 * OnSetProperty()
 * OnGetProperty()

The OnStart and OnStop functions are used to perform initialization and teardown.
These functions are normally called once per test.
The Peach engine will automatically call stop on all publishers when the test
completes.  The OnOpen and OnClose functions are used to control access to the underlying resource.
These functions are normally called once per iteration.
The Peach engine will automatically call close on all publishers when each iteration completes.

The OnOutput function is used to write all the provided data to the underlying resource.
The data is provided in a stream, and it is best to write the data to the resource block at a time
instead of making a single large contiguous buffer.
If the underlying resource only consumes data in a single contiguous buffer it is best to have a
configurable maximum size and truncate data that exceeds it.

The OnInput function tells the publisher to read data from the underlying resource.
The data is then stored internally in a seekable stream and used be Peach for cracking the data model.
If the underlying resource already provides a seekable stream (eg: a file stream) then OnInput doesn't have to do anything.
However, for publishers like Udp the OnInput function causes the next packet to be received.
When implementing the OnInput function for publishers that block, it is best to expose a user configurable input timeout.
If no data is received from the underlying resource after the timeout interval, a SoftException() should be thrown to
indicate to the Peach engine that the action did not complete successfully.

To assist developers in quickly writing publishers, Peach comes with two helper classes: StreamPublisher and BufferedStreamPublisher.
Both of these classes make it easy to quickly write publishers for IO interfaces that already implement the C# System.IO.Stream interface.
The StreamPublisher is used when the underlying stream supports the Seek() function (eg: file streams).
The BufferedStreamPublisher is used when the underlying stream does not support the Seek() function (eg: TCP Streams, SerialPort).
The BufferedStreamPublisher automatically performs asynchronous reads on the underlying stream, and buffers the accumulated data in a seekable stream.
To use the StreamPublisher, the developer only needs to override OnOpen() and set the 'this.stream' property.
To use the BufferedStreamPublisher, the developer needs to do two things. First, they need to override
OnOpen() and set this._client to the System.IO.Stream and call the StartClient() function.
Second, if extra cleanup code is required other than simply closing the stream
the developer needs to override ClientClose() and cleanup any additional resources acquired during OnOpen().

An example of a File publisher deriving from StreamPublisher.

[source,c#]
----
[Publisher("File", true)]
[Publisher("FileStream")]
[Publisher("file.FileWriter")]
[Publisher("file.FileReader")]
[Parameter("FileName", typeof(string), "Name of file to open for reading/writing")]
[Parameter("Overwrite", typeof(bool), "Replace existing file? [true/false, default true]", "true")]
[Parameter("Append", typeof(bool), "Append to end of file [true/false, default flase]", "false")]
public class FilePublisher : StreamPublisher
{
	private static NLog.Logger logger = LogManager.GetCurrentClassLogger();
	protected override NLog.Logger Logger { get { return logger; } }

	public string FileName { get; set; }
	public bool Overwrite { get; set; }
	public bool Append { get; set; }

	private FileMode fileMode = FileMode.OpenOrCreate;

	public FilePublisher(Dictionary<string, Variant> args)
		: base(args)
	{
		if (Overwrite && Append)
			throw new PeachException("File publisher does not support Overwrite and Append being enabled at once.");
		else if (Overwrite)
			fileMode = FileMode.Create;
		else if (Append)
			fileMode = FileMode.Append | FileMode.OpenOrCreate;
		else
			fileMode = FileMode.OpenOrCreate;
	}

	protected override void OnOpen()
	{
		stream = System.IO.File.Open(FileName, FileMode);
	}
}
----

An example of a Serial publisher deriving from BufferedStreamPublisher.

[source,c#]
----
[Publisher("SerialPort", true)]
[Parameter("PortName", typeof(string), "Com interface for the device to connect to")]
[Parameter("Baudrate", typeof(int), "The serial baud rate.")]
[Parameter("Parity", typeof(Parity), "The parity-checking protocol.")]
[Parameter("DataBits", typeof(int), "Standard length of data bits per byte.")]
[Parameter("StopBits", typeof(StopBits), "The standard number of stopbits per byte.")]
public class SerialPortPublisher : BufferedStreamPublisher
{
    private static NLog.Logger logger = LogManager.GetCurrentClassLogger();
    protected override NLog.Logger Logger { get { return logger; } }

    public string PortName { get; protected set; }
    public int Baudrate { get; protected set; }
    public Parity Parity { get; protected set; }
    public int DataBits { get; protected set; }
    public StopBits StopBits { get; protected set; }

    protected SerialPort _serial;

    public SerialPortPublisher(Dictionary<string, Variant> args)
        : base(args)
    {
    }

    protected override void OnOpen()
    {
        base.OnOpen();

        try
        {
            _serial = new SerialPort(PortName, Baudrate, Parity, DataBits, StopBits);
            _serial.Handshake = Handshake;
            _serial.DtrEnable = DtrEnable;
            _serial.RtsEnable = RtsEnable;
            _serial.Open();
            // Set _clientName so logs from the base class are pretty
            _clientName = _serial.PortName;
            // Set _client to use for async IO
            _client = _serial.BaseStream;
        }
        catch (Exception ex)
        {
            string msg = "Unable to open Serial Port {0}. {1}.".Fmt(PortName, ex.Message);
            Logger.Error(msg);
            throw new PeachException(msg, ex);
        }

        // Start the async read operations
        StartClient();
    }

    protected override void ClientClose()
    {
        base.ClientClose();

        // No custom closing required
        _serial = null;
    }
}
----

<<<
[[Extend_Transformer]]
=== Transformer

Peach includes support for common encoding transformations such as encryption and compression.
Custom transformers are used whenever the target requires special encoding of the data that is not included with Peach.
Custom transformer implementations must implement two functions: internalEncode and internalDecode.

The internalEncode function is called by Peach when outputting data to a publisher.
Inside this function, the provided source data of the parent data element is transformed into a new stream and the new stream is returned to Peach.
For example, the AES transformer's implementation of this function encrypts the source data and returns the encrypted data.

The internalDecode function is called by Peach when cracking input data into the transformer's parent data element.
This can occur as a result of an input action, or a DataSet being applied.
The internalDecode function is given a stream of encoded data.
The function performs the necessary decoding logic and returns a new stream of decoded data.
The decoded data is then used by the transformer's parent element for cracking.
For example, the AES transformer's implementation of this function decrypts the source data and returns the decrypted data.

<<<
[[Extend_Mutator]]
=== Mutator

Peach includes mutators for common data types and patterns.  Occasionally it is necessary
to extend the mutation capabilities with a custom mutator.  Custom mutators follow a similar pattern
to all other Peach plug-ins, implement a class that derives from the base Peach.Core.Mutator class and
decorate the class with a MutatorAttribute.

In order for Peach to select a mutator when fuzzing, every mutator must implement a static supportedDataElement function.
This function gets called with every data element in the DOM and returns true
if the mutator can mutate the data element.

An example of the supportedDataElement function for a string mutator.

[source,c#]
----
public new static bool supportedDataElement(DataElement obj)
{
	if (obj is Dom.String && obj.isMutable)
		return true;

	return false;
}
----

When the Peach engine determines that a mutator is capable of mutating a data element, an instance of the mutator class is created for each supported data element.
Once Peach creates all of the mutator instances, each mutator needs to provide the number of mutations that can be performed.
The supported mutation count is provided with the 'count' property.

Each mutator implements two functions for performing the actual mutation: sequentialMutation and randomMutation.
These functions correspond to the type of mutation strategy defined in the Peach pit.
When Peach is configured to use the Random strategy, the randomMutation function will be called to perform mutations.
When Peach is configured to use the Sequential strategy, the mutator's 'mutation' attribute will be set to the desired value (between 0 and count) and the sequentialMutation function will be called to perform mutations.

When picking random numbers inside the mutator, it is important to use the random number generator provided by the mutation strategy.
Mutators access the random number generator with the 'this.context.Random' variable.
The mutation strategy guarantees that the random number generator is different across different fuzzing iterations.
Additionally, the mutation strategy guarantees the random number generator is identical for the same iterations.
This allows Peach to produce identical mutations when replaying the same fuzz iteration to reproduce faults or when re-running a test of the same seed at a future date.

An example of a string mutator that mutates string elements with the values "Hello", "World" or "Hello World".

[source,c#]
----
[Mutator("StringMutator")]
[Description("Replace strings with hello world")]
public class HelloWorldMutator : Peach.Core.Mutator
{
	uint pos = 0;
	static string[] values = new string[] { "Hello", "World", "Hello World" };

	public StringMutator(DataElement obj)
	{
		pos = 0;
		name = "HelloWorldMutator";
	}

	public new static bool supportedDataElement(DataElement obj)
	{
		if (obj is Dom.String && obj.isMutable)
			return true;

		return false;
	}

	public override int count
	{
		get { return values.Length; }
	}

	public override uint mutation
	{
		get { return pos; }
		set { pos = value; }
	}

	public override void sequentialMutation(DataElement obj)
	{
		obj.mutationFlags = MutateOverride.Default;
		obj.MutatedValue = new Variant(values[pos]);
	}

	public override void randomMutation(DataElement obj)
	{
		obj.mutationFlags = MutateOverride.Default;
		obj.MutatedValue = new Variant(this.context.Random.Choice<string>(values));
	}
}
----

In order for Peach to select a mutator when fuzzing, every mutator must implement a static supportedDataElement function.
This function gets called with every data element in the DOM and returns true
if the mutator can mutate the data element.

An example of the supportedDataElement function for a string mutator.

[source,c#]
----
public new static bool supportedDataElement(DataElement obj)
{
	if (obj is Dom.String && obj.isMutable)
		return true;

	return false;
}
----

When the Peach engine determines that a mutator is capable of mutating a data element, an instance of the mutator class is created for each supported data element.
Once Peach creates all of the mutator instances, each mutator needs to provide the number of mutations that can be performed.
The supported mutation count is provided with the 'count' property.

Each mutator implements two functions for performing the actual mutation: sequentialMutation and randomMutation.
These functions correspond to the type of mutation strategy defined in the Peach pit.
When Peach is configured to use the Random strategy, the randomMutation function will be called to perform mutations.
When Peach is configured to use the Sequential strategy, the mutator's 'mutation' attribute will be set to the desired value (between 0 and count) and the sequentialMutation function will be called to perform mutations.

When picking random numbers inside the mutator, it is important to use the random number generator provided by the mutation strategy.
Mutators access the random number generator with the 'this.context.Random' variable.
The mutation strategy guarantees that the random number generator is different across different fuzzing iterations.
Additionally, the mutation strategy guarantees the random number generator is identical for the same iterations.
This allows Peach to produce identical mutations when replaying the same fuzz iteration to reproduce faults or when re-running a test of the same seed at a future date.

An example of a string mutator that mutates string elements with the values "Hello", "World" or "Hello World".

[source,c#]
----
[Mutator("StringMutator")]
[Description("Replace strings with hello world")]
public class HelloWorldMutator : Peach.Core.Mutator
{
	uint pos = 0;
	static string[] values = new string[] { "Hello", "World", "Hello World" };

	public StringMutator(DataElement obj)
	{
		pos = 0;
		name = "HelloWorldMutator";
	}

	public new static bool supportedDataElement(DataElement obj)
	{
		if (obj is Dom.String && obj.isMutable)
			return true;

		return false;
	}

	public override int count
	{
		get { return values.Length; }
	}

	public override uint mutation
	{
		get { return pos; }
		set { pos = value; }
	}

	public override void sequentialMutation(DataElement obj)
	{
		obj.mutationFlags = MutateOverride.Default;
		obj.MutatedValue = new Variant(values[pos]);
	}

	public override void randomMutation(DataElement obj)
	{
		obj.mutationFlags = MutateOverride.Default;
		obj.MutatedValue = new Variant(this.context.Random.Choice<string>(values));
	}
}
----

<<<
[[Extend_Agent]]
=== Agent

Custom agents are useful when the target system does not support a .NET runtime (like Mono) or the device is too slow (speed is a common problem for embedded devices that require running a native agent in C/C++).

Agents in Peach communicate over protocols called channels.  While you can develop custom channel protocols, an exiting channel usually creates a custom Peach agent. Agents can be written in any language; To make it easy to author your own, Peach comes with some example implementations designed for languages like as Python and C++. The REST based protocol (which transmits data in JSON messages) is the easiest channel protocol to use with custom agents.

When you write a custom publisher, we recommend you start with one of the examples in the SDK and extend it to meet your requirements. The examples in the SDK already implement the agent channel protocol with stub methods ready to be implemented. If this is not an option, the following example channel sessions can be used as documentation for the protocol. The second example includes the use of a remote publisher.

.Sample session
=========================

This example shows a complete agent session using the REST JSON agent channel (protocol prefix _http_) with matching pit.

[source,xml]
----
<Agent name="TheAgent" location="http://127.0.0.1:9980">
	<Monitor class="WindowsDebugger">
		<Param name="CommandLine" value="mspaint.exe fuzzed.png" />
		<Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" />
		<Param name="StartOnCall" value="ScoobySnacks"/>
	</Monitor>
	<Monitor class="PageHeap">
		<Param name="Executable" value="mspaint.exe"/>
		<Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" />
	</Monitor>
</Agent>

<Test name="Default">
	<Agent ref="TheAgent"/>
	<StateModel ref="TheState"/>

	<Publisher class="File">
		<Param name="FileName" value="fuzzed.png"/>
	</Publisher>

</Test>
----

[source,java]
----
GET /Agent/AgentConnect
<< { "Status":"true" }

POST /Agent/StartMonitor?name=Monitor_0&cls=WindowsDebugger
>> {"args":{"CommandLine":"mspaint.exe fuzzed.png","WinDbgPath":"C:\\Program Files (x86)\\Debugging Tools for Windows (x86)","StartOnCall":"ScoobySnacks"}}
<< { "Status":"true" }

POST /Agent/StartMonitor?name=Monitor_1&cls=PageHeap
>> {"args":{"Executable":"mspaint.exe","WinDbgPath":"C:\\Program Files (x86)\\Debugging Tools for Windows (x86)"}}
<< { "Status":"true" }

GET /Agent/SessionStarting
<< { "Status":"true" }

GET /Agent/IterationStarting?iterationCount=1&isReproduction=False
<< { "Status":"true" }

GET /Agent/IterationFinished
<< { "Status":"true" }

GET /Agent/DetectedFault
<< { "Status":"true" }
// Status of true indicates a fault was detected. False for no fault.

GET /Agent/GetMonitorData
<< {
	"Results":[
		{
			"iteration":0,
			"controlIteration":false,
			"controlRecordingIteration":false,
			"type":0,  (0 unknown, 1 Fault, 2 Data)
			"detectionSource":null,
			"title":null,
			"description":null,
			"majorHash":null,
			"minorHash":null,
			"exploitability":null,
			"folderName":null,
			"collectedData":[
				{"Key":"data1","Value":"AA=="}
			]
		}
	]
}

GET /Agent/IterationStarting?iterationCount=1&isReproduction=True
<< { "Status":"true" }

GET /Agent/IterationFinished
<< { "Status":"true" }

GET /Agent/DetectedFault
<< { "Status":"true" }
// Status of true indicates a fault was detected. False for no fault.

GET /Agent/GetMonitorData
<< {
	"Results":[
		{
			"iteration":0,
			"controlIteration":false,
			"controlRecordingIteration":false,
			"type":0,  (0 unknown, 1 Fault, 2 Data)
			"detectionSource":null,
			"title":null,
			"description":null,
			"majorHash":null,
			"minorHash":null,
			"exploitability":null,
			"folderName":null,
			"collectedData":[
				{"Key":"data1","Value":"AA=="}
			]
		}
	]
}

GET /Agent/Publisher/stop
<< { "Status":"true" }

GET /Agent/SessionFinished
<< { "Status":"true" }

GET /Agent/StopAllMonitors
<< { "Status":"true" }

GET /Agent/AgentDisconnect
<< { "Status":"true" }

----
=========================

.Sample session with remote publisher
=========================
This example shows the channel messages when a remote publisher is in use.

[source,xml]
----
<Agent name="TheAgent" location="http://127.0.0.1:9980">
	<Monitor class="WindowsDebugger">
		<Param name="CommandLine" value="mspaint.exe fuzzed.png" />
		<Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" />
		<Param name="StartOnCall" value="ScoobySnacks"/>
	</Monitor>
	<Monitor class="PageHeap">
		<Param name="Executable" value="mspaint.exe"/>
		<Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" />
	</Monitor>
</Agent>

<Test name="Default">
	<Agent ref="TheAgent"/>
	<StateModel ref="TheState"/>

	<Publisher class="Remote">
		<Param name="Agent" value="TheAgent"/>
		<Param name="Class" value="File"/>
		<Param name="FileName" value="fuzzed.png"/>
	</Publisher>

</Test>
----

[source,java]
----
GET /Agent/AgentConnect
<< { "Status":"true" }

POST /Agent/StartMonitor?name=Monitor_0&cls=WindowsDebugger
>> {"args":{"CommandLine":"mspaint.exe fuzzed.png","WinDbgPath":"C:\\Program Files (x86)\\Debugging Tools for Windows (x86)","StartOnCall":"ScoobySnacks"}}
<< { "Status":"true" }

POST /Agent/StartMonitor?name=Monitor_1&cls=PageHeap
>> {"args":{"Executable":"mspaint.exe","WinDbgPath":"C:\\Program Files (x86)\\Debugging Tools for Windows (x86)"}}
<< { "Status":"true" }

GET /Agent/SessionStarting
<< { "Status":"true" }

GET /Agent/IterationStarting?iterationCount=1&isReproduction=False
<< { "Status":"true" }

POST /Agent/Publisher/Set_Iteration
>> {"iteration":1}
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_IsControlIteration
>> {"isControlIteration":true}
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_IsControlIteration
>> {"isControlIteration":true}
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_Iteration
>> {"iteration":1}
<< { "error":"false", "errorString":null }

GET /Agent/Publisher/start
<< { "error":"false", "errorString":null }

GET /Agent/Publisher/open
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/output
>> {"data":"SGVsbG8gV29ybGQ="}
<< { "error":"false", "errorString":null }

GET /Agent/Publisher/close
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/call
>> {"method":"ScoobySnacks","args":[{"name":"p1","data":"SGVsbG8gV29ybGQ=","type":0}]}
<< { "error":"false", "errorString":null }

GET /Agent/IterationFinished
<< { "Status":"true" }

GET /Agent/DetectedFault
<< { "Status":"true" }
// Status of true indicates a fault was detected. False for no fault.

GET /Agent/GetMonitorData
<< {
	"Results":[
		{
			"iteration":0,
			"controlIteration":false,
			"controlRecordingIteration":false,
			"type":0,  (0 unknown, 1 Fault, 2 Data)
			"detectionSource":null,
			"title":null,
			"description":null,
			"majorHash":null,
			"minorHash":null,
			"exploitability":null,
			"folderName":null,
			"collectedData":[
				{"Key":"data1","Value":"AA=="}
			]
		}
	]
}

GET /Agent/IterationStarting?iterationCount=1&isReproduction=True
<< { "Status":"true" }

POST /Agent/Publisher/Set_Iteration
>> {"iteration":1}
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_IsControlIteration
>> {"isControlIteration":true}
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_IsControlIteration
>> {"isControlIteration":true}
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_Iteration
>> {"iteration":1}
<< { "error":"false", "errorString":null }

GET /Agent/Publisher/start
<< { "error":"false", "errorString":null }

GET /Agent/Publisher/open
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/output
>> {"data":"SGVsbG8gV29ybGQ="}
<< { "error":"false", "errorString":null }

GET /Agent/Publisher/close
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/call
>> {"method":"ScoobySnacks","args":[{"name":"p1","data":"SGVsbG8gV29ybGQ=","type":0}]}
<< { "error":"false", "errorString":null }

GET /Agent/IterationFinished
<< { "Status":"true" }

GET /Agent/DetectedFault
<< { "Status":"true" }
// Status of true indicates a fault was detected. False for no fault.

GET /Agent/GetMonitorData
<< {
	"Results":[
		{
			"iteration":0,
			"controlIteration":false,
			"controlRecordingIteration":false,
			"type":0,  (0 unknown, 1 Fault, 2 Data)
			"detectionSource":null,
			"title":null,
			"description":null,
			"majorHash":null,
			"minorHash":null,
			"exploitability":null,
			"folderName":null,
			"collectedData":[
				{"Key":"data1","Value":"AA=="}
			]
		}
	]
}

GET /Agent/Publisher/stop
<< { "Status":"true" }

GET /Agent/SessionFinished
<< { "Status":"true" }

GET /Agent/StopAllMonitors
<< { "Status":"true" }

GET /Agent/AgentDisconnect
<< { "Status":"true" }
----
=========================
