[[Extending]]
== Extending Peach

Peach uses custom implementations of xref:Fixup[Fixups], xref:Transformer[Transformers], xref:Publisher[Publishers], and xref:Monitors[Monitors] to extend its functionality.

All extensions follow the same paradigm:
-- 
. Create a C# class that derives from the appropriate Peach base class.
. Decorate the class with the appropriate plugin attribute.
. Compile the class into an assembly and place the assembly in the Peach directory.
--
When Peach runs, it will automatically reflect all assemblies to generate the list of xref:Fixup[Fixups], xref:Transformer[Transformers], xref:Publisher[Publishers], and xref:Monitors[Monitors].

// TODO - Analyzer
// TODO - Logger

{product} was designed to be extended, allowing  you to increase Peach's capabilities. The most common reasons for extending Peach include: 
--
* Custom validation algorithms (such as checksums) 
* Custom publishers (I/O adapters), 
* Monitoring
--
Peach allows you to write custom agents, loggers, analyzers, and strategies. 

This section covers the most common types of extensions to Peach.

<<<
[[Extend_Plugins]]
=== Peach Plug-ins

If your target has something in its data model that Peach does not support (like a custom checksum algorithm or a custom data format), you may need to extend Peach's functionality by using Peach plugins. 

Peach plugins take a C# dictionary as a construction argument.
This argument dictionary is populated with the Param elements names and values defined in the Peach Pit.

To see a list of all detected plugins and their parameters, run `peach --showenv`.

Peach plugins use ParameterAttribute to define all of their supported configuration arguments (name, type, description, and optional default value).

 * The name and type specified in the ParameterAttribute must match a public property on the plugin class.
 * If the name parameter happens to be a C# reserved keyword, prefix the associated class property with an underscore.
 
 * The default value is always given as a string, regardless of the type of the parameter. 
 
NOTE: If the default value is omitted from the ParameterAttribute, Peach treats the parameter as required.

ParameterParser.Parse() uses the arguments dictionary to automatically populate all plugin properties.

 * When populating the properties, type conversion converts the string specified in the pit to the concrete type defined in the plugin.
 * When performing automatic type conversion, the ParameterParser supports System.Enum as well as any type that implements IConvertible.

This method uses reflection to:

 * Enforce missing required parameters.
 * Initialize optional parameters from default values.
 * Convert types from string to a concrete type.
 * Validate all type conversions
 ** -100 is valid int.
 ** -100 is not a valid byte.

General Peach plugin best practices:

 * Use stream operations whenever possible.
 * Avoid using large arrays of contiguous data.
 * Validate parameter types in the plugin constructors.
 * Provide useful error messages.
 * Throw PeachException() when non-recoverable errors occur such as:
 ** A parameter is out of range.
 ** A user lacks appropriate permissions.
 * Throw SoftException when recoverable errors occur such as:
 ** A file is in use.
 ** An error occurs when starting a process.
 ** A socket connection is refused.

==== Examples

.Transformer
==========================
This example shows the arguments in the JsEncode transformer constructor.

[source,java]
----
[Transformer("JsEncode")]
public class JsEncode : Transformer
{
	public JsEncode(Dictionary<string, Variant> args)
		: base(args)
	{
	}
}
----
==========================

.Fixup
==========================
This example shows the class definition for a custom fixup called "MyFixup".

[source,java]
----
[Fixup("MyFixup", true)]
public class MyFixup : Peach.Core.Fixup
{
}
----
==========================

.ParameterAttribute
==========================
This example shows the ParameterAttribute usage.

[source,java]
----
[Transformer("MyTransformer")]
[Parameter("level", typeof(int), "Specifies the level, default: 9", "9")]
[Parameter("class", typeof(string), "Specifies the class, required!")]
public class MyTransformer : Transformer
{
	// Type matches typeof(int) in ParameterAttribute
	public int level { get; set; }

	// Name is '_class' since 'class' is a C# keyword
	public string _class { get; set; }

	public MyTransformer(Dictionary<string, Variant> args)
		: base(args)
	{
	}
}
----
==========================

.Transformer
==========================
This example shows the class definition for a custom transformer called "MyTransformer".

[source,java]
----
[Transformer("MyTransformer", true)]
public class MyTransformer : Peach.Core.Transformer
{
}
----
==========================

.Publisher
==========================
This example shows the class definition for a custom publisher called "MyPublisher".

[source,java]
----
[Publisher("MyPublisher", true)]
public class MyPublisher : Peach.Core.Publisher
{
}
----
==========================

.Monitor
==========================
This example shows the class definition for a custom monitor called "MyMonitor".

[source,java]
----
[Monitor("MyMonitor", true)]
public class MyMonitor : Peach.Core.Monitor
{
}
---- 
==========================

<<<
[[Extend_Fixup]]
=== Fixup

A fixup computes a value based on one or more data elements.Since the value is  
based on other elements, each fixup tracks whenever a referenced element changes so it  can recompute its value. For example, the Crc32 fixup needs to know whenever the referenced element changes, so that a new CRC can be computed. 

Each Fixup implementation tells the base Fixup class which parameters are other data elements by passing their data element parameters' names as arguments to its base class constructor.

Each fixup implementation needs to implement a single function: fixupImpl().
This function returns the result of the fixup computation.

It is important to maintain the element type information when returning results from a fixup.
The data element type returned by the fixup should match the data element type of the resulting field; the only exception is a string that can be the resulting field when the fixup element inputs a number.

If the fixup evaluates to an integer, an int type should be returned.  Similarly, if the fixup evaluates to a string, a string type should be returned. This allows Peach to perform proper byte encoding when creating the final value for a data element.

Because the Crc fixup returns its value in an unsigned integer type, Peach outputs the bytes in the endian-ness defined on the parent data element.

Inside of fixupImpl(), the resolved data element references are obtained through the dictionary 'this.elements'.
The key to this dictionary is the name of the parameter (eg: 'ref') and the value is the appropriate data element.

==== Examples

.Single data element
==========================
This is an example of a fixup with a single data element reference.

[source,java]
----
[Fixup("CustomFixupOne", true)]
[Parameter("ref", typeof(string), "Reference to data element")]
[Serializable]
public class CustomFixupOne : Fixup
{
	public CustomFixupThree(DataElement parent, Dictionary<string, Variant> args)
		: base(parent, args, "ref")
	{
	}
}
----
==========================

.Multi-data element
==========================
This is an example of a fixup with three data element references.

[source,java]
----
[Fixup("CustomFixupThree", true)]
[Parameter("refOne", typeof(string), "Reference to first data element")]
[Parameter("refTwo", typeof(string), "Reference to second data element")]
[Parameter("refThree", typeof(string), "Reference to third data element")]
[Serializable]
public class CustomFixupThree : Fixup
{
	public CustomFixupThree(DataElement parent, Dictionary<string, Variant> args)
		: base(parent, args, "refOne", "refTwo", "refThree")
	{
	}
}
----
==========================

.fixupImpl function
==========================
This is an example of the fixupImpl function of a Crc fixup.

[source,java]
----
protected override Variant fixupImpl()
{
	// Get the element we need to compute the CRC of
	var elem = this.elements["ref"];
	// Get the stream of data for the target element
	var data = elem.Value;

	// Ensure we are at the beginning of the data
	data.Seek(0, System.IO.SeekOrigin.Begin);

	// Initialize the CRCTool
	CRCTool crcTool = new CRCTool();
	crcTool.Init(CRCTool.CRCCode.CRC32);

	// Return the CRC of data as a uint
	return new Variant((uint)crcTool.crctablefast(data));
}
----
==========================

<<<
[[Extend_Monitor]]
=== Monitor

Custom monitors must implement the following functions:

 * StopMonitor()
 * SessionStarting()
 * SessionFinished()
 * IterationStarting()
 * IterationFinished()
 * DetectedFault()
 * GetMonitorData()
 * MustStop()
 * Message()

The SessionStarting and SessionFinished functions are called once per fuzzing session.
These functions are responsible for any initialization and cleanup required by the monitor.
Monitors can run remotely and multiple monitors can be defined in a Peach pit.
It is possible that calling SessionStarting on the first monitor
triggers some behavior on the target that allows subsequent monitors to be able to start without error.
This means things like parameter validation and initialization should occur in the SessionStarting function
as opposed to the monitor's constructor.

The IterationStarting and IterationFinished functions are called once per fuzzing iteration.
All per-iteration logic is implemented in these functions.
Monitors that perform per-iteration process control will start and stop the target process in these functions.
Most importantly, any per-iteration state must be reset in calls to IterationFinished().
The current fuzzing iteration is driven by the Peach engine, and monitors must not use past iterations to make any
assumptions about future iterations.

The Message function is used to signal monitors at specific places in the StateModel execution.
This functionality is primarily used for state synchronization.
It allows the monitor to pause the execution of the StateModel at a specific point until some desired event happens.
For example, a custom monitor could use the Message function to wait until a proprietary embedded device
has rebooted and is ready to accept input data.

It is important to note that call actions on the "Peach.Agent" publisher result in 
the Message function being called on every monitor. Each monitor must filter for 
their desired messages, ignoring all unexpected message calls by returning null.

The DetectedFault and GetMonitorData functions are used to report faults back to 
Peach. At the end of each iteration, the Peach engine calls DetectedFault() on 
every monitor. If any monitor reports that a fault occurred, Peach calls 
GetMonitorData() on every monitor. The GetMonitorData function returns a Fault record, and the type of the record can be either Fault or Data.



Fault Detection:

 * Return true from DetectedFault().
 * Any monitor that detects a fault causes Peach to call ALL monitors to return monitor data.
 * GetMonitorData() returns applicable data.
 * Returned fault can be +fault+ or +data+.
 ** Debugger stack trace is +fault+.
 ** Network packet capture is +data+.
 ** Log file is +data+.
 * Faults can include a hash for bucketing information.

Monitor best practices:

 * Indicate errors with SoftExceptions().
 * Keep monitors simple.
 * Prefer multiple small monitors.
 * Agent/Monitor order within a pit is honored by Peach.
 ** Starting functions are called in order.
 ** Finished functions are called in reverse order.
 * Avoid one large complicated monitor.
 * Remember monitors can run in remote agents.
 * Maintain cross platform compatibility.
 ** Windows Peach with Linux Agent.

<<<
[[Extend_Publisher]]
=== Publisher

Publishers need to be extended whenever Peach needs to send or receive data through a custom IO channel.
Publishers support both a 'stream' view (open, input, output, close) and a 'function' view (call, setProperty, getProperty).
Each publisher method corresponds to a single action type used in the StateModel.
While publishers can support all action types, most do not need to.  For example, the File publisher does not
implement call, accept, setProperty and getProperty.
It is up to the developer to implement the appropriate set of functions.

All of the publisher's public functions are implemented in the base class.
The public functions ensure the publisher is in the proper state and 
that they call the protected implementation functions when needed. For example, the public open function
calls the protected OnOpen function only when the publisher is not open.
When developers implement custom publishers, they override the protected functions.
The default implementation of these protected functions is to throw a NotImplementedException().

The list of user overridable functions are:

 * OnStart()
 * OnStop()
 * OnOpen()
 * OnClose()
 * OnAccept()
 * OnInput()
 * OnOutput()
 * OnCall()
 * OnSetProperty()
 * OnGetProperty()

The OnStart and OnStop functions perform initialization and teardown.
These functions are normally called once per test.
The Peach engine automatically calls stop on all publishers when the test
completes. The OnOpen and OnClose functions control access to the underlying resource.
These functions are normally called once per iteration.
The Peach engine automatically calls close on all publishers when each iteration completes.

The OnOutput function writes all the provided data to the underlying resource.
The data is provided in a stream, and it is best to write the data to the resource one block at a time instead of making a single large contiguous buffer.
If the underlying resource only consumes data in a single contiguous buffer, it is best to have a configurable maximum size and truncate data that exceeds it.

The OnInput function tells the publisher to read data from the underlying resource.
The data is then stored internally in a seekable stream and used by Peach for cracking the data model.
If the underlying resource already provides a seekable stream (eg: a file stream) then OnInput doesn't have to do anything.
However, for publishers like Udp, the OnInput function causes the next packet to be received.
When implementing the OnInput function for publishers that block, it is best to expose a user configurable input timeout.
If no data is received from the underlying resource after the timeout interval, a SoftException() should be thrown to
indicate to the Peach engine that the action did not complete successfully.

To assist developers in quickly writing publishers, Peach comes with two helper classes: StreamPublisher and BufferedStreamPublisher.
Both of these classes make it easy to quickly write publishers for IO interfaces that already implement the C# System.IO.Stream interface.

* StreamPublisher is used when the underlying stream supports the Seek() function (eg: file streams). To use the StreamPublisher, the developer only needs to override OnOpen() and set the 'this.stream' property.

* BufferedStreamPublisher is used when the underlying stream does not support the Seek() function (eg: TCP Streams, SerialPort). The BufferedStreamPublisher automatically performs asynchronous reads on the underlying stream, and buffers the accumulated data in a seekable stream.
+
To use the BufferedStreamPublisher, the developer needs to do two things. 

.. Override OnOpen() and set this._client to the System.IO.Stream and call the StartClient() function.
.. If extra cleanup code is required other than simply closing the stream,
the developer needs to override ClientClose() and clean up any additional resources acquired during OnOpen().

An example of a File publisher deriving from StreamPublisher.

[source,java]
----
[Publisher("File", true)]
[Publisher("FileStream")]
[Publisher("file.FileWriter")]
[Publisher("file.FileReader")]
[Parameter("FileName", typeof(string), "Name of file to open for reading/writing")]
[Parameter("Overwrite", typeof(bool), "Replace existing file? [true/false, default true]", "true")]
[Parameter("Append", typeof(bool), "Append to end of file [true/false, default false]", "false")]
public class FilePublisher : StreamPublisher
{
	private static NLog.Logger logger = LogManager.GetCurrentClassLogger();
	protected override NLog.Logger Logger { get { return logger; } }

	public string FileName { get; set; }
	public bool Overwrite { get; set; }
	public bool Append { get; set; }

	private FileMode fileMode = FileMode.OpenOrCreate;

	public FilePublisher(Dictionary<string, Variant> args)
		: base(args)
	{
		if (Overwrite && Append)
			throw new PeachException("File publisher does not support Overwrite and Append being enabled at once.");
		else if (Overwrite)
			fileMode = FileMode.Create;
		else if (Append)
			fileMode = FileMode.Append | FileMode.OpenOrCreate;
		else
			fileMode = FileMode.OpenOrCreate;
	}

	protected override void OnOpen()
	{
		stream = System.IO.File.Open(FileName, FileMode);
	}
}
----

An example of a Serial publisher deriving from BufferedStreamPublisher.

[source,java]
----
[Publisher("SerialPort", true)]
[Parameter("PortName", typeof(string), "Com interface for the device to connect to")]
[Parameter("Baudrate", typeof(int), "The serial baud rate.")]
[Parameter("Parity", typeof(Parity), "The parity-checking protocol.")]
[Parameter("DataBits", typeof(int), "Standard length of data bits per byte.")]
[Parameter("StopBits", typeof(StopBits), "The standard number of stop bits per byte.")]
public class SerialPortPublisher : BufferedStreamPublisher
{
    private static NLog.Logger logger = LogManager.GetCurrentClassLogger();
    protected override NLog.Logger Logger { get { return logger; } }

    public string PortName { get; protected set; }
    public int Baudrate { get; protected set; }
    public Parity Parity { get; protected set; }
    public int DataBits { get; protected set; }
    public StopBits StopBits { get; protected set; }

    protected SerialPort _serial;

    public SerialPortPublisher(Dictionary<string, Variant> args)
        : base(args)
    {
    }

    protected override void OnOpen()
    {
        base.OnOpen();

        try
        {
            _serial = new SerialPort(PortName, Baudrate, Parity, DataBits, StopBits);
            _serial.Handshake = Handshake;
            _serial.DtrEnable = DtrEnable;
            _serial.RtsEnable = RtsEnable;
            _serial.Open();
            // Set _clientName so logs from the base class are pretty
            _clientName = _serial.PortName;
            // Set _client to use for async IO
            _client = _serial.BaseStream;
        }
        catch (Exception ex)
        {
            string msg = "Unable to open Serial Port {0}. {1}.".Fmt(PortName, ex.Message);
            Logger.Error(msg);
            throw new PeachException(msg, ex);
        }

        // Start the async read operations
        StartClient();
    }

    protected override void ClientClose()
    {
        base.ClientClose();

        // No custom closing required
        _serial = null;
    }
}
----

Some Publishers use the Function view metaphor (call, setProperty, getProperty). For this type of Publisher, sharing information occurs by implementing properties of the publisher that other parts of the Peach can access. For example, the StateModel or a script could make use of the ports that a Publisher uses, as in the following example.

NOTE: Remote agents can host Publishers; therefore, Publishers should not directly use the IterationStateStore bag.

An example of a Serial publisher deriving from BufferedStreamPublisher.

[source,java]
    protected override Variant OnGetProperty(string property)
    {
        switch(property)
        {
            case "Port": 
                return new Variant(Port);
           case "SrcPort":
                return new Variant(SrcPort);
        }
        return base.OnGetProperty(property);
    }

The property is then accessible in the state model using the getProperty action, or using a script as in the following:

[source,java]
Port = int(context.test.publishers[0].getProperty(‘Port’))


<<<
[[Extend_Transformer]]
=== Transformer

Peach includes support for common encoding transformations such as encryption and compression.
Custom transformers are used whenever the target requires special encoding of the data not included with Peach.
Custom transformer implementations must implement two functions: internalEncode and internalDecode.

Peach calls the internalEncode function when outputting data to a publisher.
Inside this function, the provided source data of the parent data element is transformed into a new stream and the new stream is returned to Peach.
For example, the AES transformer's implementation of this function encrypts the source data and returns the encrypted data.

Peach calls the internalDecode function when cracking input data into the transformer's parent data element.
This function call results from an input action or from a DataSet being applied.
The internalDecode function is given a stream of encoded data.
The function performs the necessary decoding logic and returns a new stream of decoded data.
The decoded data is then used by the transformer's parent element for cracking.
For example, the AES transformer's implementation of this function decrypts the source data and returns the decrypted data.

<<<
[[Extend_Mutator]]
=== Mutator

Peach includes mutators for common data types and patterns.  Occasionally it is necessary
to extend the mutation capabilities with a custom mutator.  Custom mutators follow a similar pattern
to all other Peach plug-ins, implement a class that derives from the base class,  Peach.Core.Mutator class, and
decorate the class with a MutatorAttribute.

In order for Peach to select a mutator when fuzzing, every mutator must implement a static supportedDataElement function.
This function gets called with every data element in the DOM and returns true
if the mutator can mutate the data element.

An example of the supportedDataElement function for a string mutator.

[source,java]
----
public new static bool supportedDataElement(DataElement obj)
{
	if (obj is Dom.String && obj.isMutable)
		return true;

	return false;
}
----

When the Peach engine determines that a mutator is capable of mutating a data element, an instance of the mutator class is created for each supported data element.
Once Peach creates all of the mutator instances, each mutator needs to provide the number of mutations that can be performed.
The supported mutation count is provided with the 'count' property.

Each mutator implements two functions for performing the actual mutation: sequentialMutation and randomMutation.
These functions correspond to the type of mutation strategy defined in the Peach pit.
When the Peach configuration uses the Random strategy, the randomMutation function performs mutations.
When the Peach configuration uses the Sequential strategy, the mutator's 'mutation' attribute will be set to the desired value (between 0 and count) and the sequentialMutation function performs mutations.

When picking random numbers inside the mutator, it is important to use the random number generator provided by the mutation strategy.
Mutators access the random number generator with the 'this.context.Random' variable.
The mutation strategy guarantees that the random number generator is different across different fuzzing iterations.
Additionally, the mutation strategy guarantees the random number generator is identical for the same iterations.
This allows Peach to produce identical mutations when replaying the same fuzz iteration to reproduce faults or when re-running a test of the same seed at a future date.

An example of a string mutator that mutates string elements with the values "Hello", "World" or "Hello World".

[source,java]
----
[Mutator("StringMutator")]
[Description("Replace strings with hello world")]
public class HelloWorldMutator : Peach.Core.Mutator
{
	uint pos = 0;
	static string[] values = new string[] { "Hello", "World", "Hello World" };

	public StringMutator(DataElement obj)
	{
		pos = 0;
		name = "HelloWorldMutator";
	}

	public new static bool supportedDataElement(DataElement obj)
	{
		if (obj is Dom.String && obj.isMutable)
			return true;

		return false;
	}

	public override int count
	{
		get { return values.Length; }
	}

	public override uint mutation
	{
		get { return pos; }
		set { pos = value; }
	}

	public override void sequentialMutation(DataElement obj)
	{
		obj.mutationFlags = MutateOverride.Default;
		obj.MutatedValue = new Variant(values[pos]);
	}

	public override void randomMutation(DataElement obj)
	{
		obj.mutationFlags = MutateOverride.Default;
		obj.MutatedValue = new Variant(this.context.Random.Choice<string>(values));
	}
}
----

In order for Peach to select a mutator when fuzzing, every mutator must implement a static supportedDataElement function.
This function is called with every data element in the DOM and returns true
if the mutator can mutate the data element.

An example of the supportedDataElement function for a string mutator.

[source,java]
----
public new static bool supportedDataElement(DataElement obj)
{
	if (obj is Dom.String && obj.isMutable)
		return true;

	return false;
}
----

<<<
[[Extend_Agent]]
=== Agent

Custom agents are useful when the target system does not support a .NET runtime (like Mono) or the device is too slow (speed is a common problem for embedded devices that require running a native agent in C/C++).

Agents in Peach communicate over protocols called channels.  While you can develop custom channel protocols, an existing channel usually creates a custom Peach agent. Agents can be written in any language; To make it easy to author your own, Peach comes with some example implementations designed for languages like as Python and C++. The REST based protocol (which transmits data in JSON messages) is the easiest channel protocol to use with custom agents.

When you write a custom publisher, we recommend you start with one of the examples in the SDK and extend it to meet your requirements. The examples in the SDK already implement the agent channel protocol with stub methods ready to be implemented. If this is not an option, the following example channel sessions can be used as documentation for the protocol. The second example includes the use of a remote publisher.

.Sample session
=========================

This example shows a complete agent session using the REST JSON agent channel (protocol prefix _http_) with matching pit.

[source,xml]
----
<Agent name="TheAgent" location="http://127.0.0.1:9980">
	<Monitor class="WindowsDebugger">
		<Param name="Executable" value="mspaint.exe" />
		<Param name="Arguments" value="fuzzed.png" />
		<Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" />
		<Param name="StartOnCall" value="ScoobySnacks"/>
	</Monitor>
	<Monitor class="PageHeap">
		<Param name="Executable" value="mspaint.exe"/>
		<Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" />
	</Monitor>
</Agent>

<Test name="Default">
	<Agent ref="TheAgent"/>
	<StateModel ref="TheState"/>

	<Publisher class="File">
		<Param name="FileName" value="fuzzed.png"/>
	</Publisher>

</Test>
----

[source,java]
----
GET /Agent/AgentConnect
<< { "Status":"true" }

POST /Agent/StartMonitor?name=Monitor_0&cls=WindowsDebugger
>> {"args":{"Executable":"mspaint.exe,"Arguments":"fuzzed.png","WinDbgPath":"C:\\Program Files (x86)\\Debugging Tools for Windows (x86)","StartOnCall":"ScoobySnacks"}}
<< { "Status":"true" }

POST /Agent/StartMonitor?name=Monitor_1&cls=PageHeap
>> {"args":{"Executable":"mspaint.exe","WinDbgPath":"C:\\Program Files (x86)\\Debugging Tools for Windows (x86)"}}
<< { "Status":"true" }

GET /Agent/SessionStarting
<< { "Status":"true" }

GET /Agent/IterationStarting?iterationCount=1&isReproduction=False
<< { "Status":"true" }

GET /Agent/IterationFinished
<< { "Status":"true" }

GET /Agent/DetectedFault
<< { "Status":"true" }
// Status of true indicates a fault was detected. False for no fault.

GET /Agent/GetMonitorData
<< {
	"Results":[
		{
			"iteration":0,
			"controlIteration":false,
			"controlRecordingIteration":false,
			"type":0,  (0 unknown, 1 Fault, 2 Data)
			"detectionSource":null,
			"title":null,
			"description":null,
			"majorHash":null,
			"minorHash":null,
			"exploitability":null,
			"folderName":null,
			"collectedData":[
				{"Key":"data1","Value":"AA=="}
			]
		}
	]
}

GET /Agent/IterationStarting?iterationCount=1&isReproduction=True
<< { "Status":"true" }

GET /Agent/IterationFinished
<< { "Status":"true" }

GET /Agent/DetectedFault
<< { "Status":"true" }
// Status of true indicates a fault was detected. False for no fault.

GET /Agent/GetMonitorData
<< {
	"Results":[
		{
			"iteration":0,
			"controlIteration":false,
			"controlRecordingIteration":false,
			"type":0,  (0 unknown, 1 Fault, 2 Data)
			"detectionSource":null,
			"title":null,
			"description":null,
			"majorHash":null,
			"minorHash":null,
			"exploitability":null,
			"folderName":null,
			"collectedData":[
				{"Key":"data1","Value":"AA=="}
			]
		}
	]
}

GET /Agent/Publisher/stop
<< { "Status":"true" }

GET /Agent/SessionFinished
<< { "Status":"true" }

GET /Agent/StopAllMonitors
<< { "Status":"true" }

GET /Agent/AgentDisconnect
<< { "Status":"true" }

----
=========================

.Sample session with remote publisher
=========================
This example shows the channel messages when a remote publisher is in use.

[source,xml]
----
<Agent name="TheAgent" location="http://127.0.0.1:9980">
	<Monitor class="WindowsDebugger">
		<Param name="Executable" value="mspaint.exe" />
		<Param name="Arguments" value="fuzzed.png" />
		<Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" />
		<Param name="StartOnCall" value="ScoobySnacks"/>
	</Monitor>
	<Monitor class="PageHeap">
		<Param name="Executable" value="mspaint.exe"/>
		<Param name="WinDbgPath" value="C:\Program Files (x86)\Debugging Tools for Windows (x86)" />
	</Monitor>
</Agent>

<Test name="Default">
	<Agent ref="TheAgent"/>
	<StateModel ref="TheState"/>

	<Publisher class="Remote">
		<Param name="Agent" value="TheAgent"/>
		<Param name="Class" value="File"/>
		<Param name="FileName" value="fuzzed.png"/>
	</Publisher>

</Test>
----

[source,java]
----
GET /Agent/AgentConnect
<< { "Status":"true" }

POST /Agent/StartMonitor?name=Monitor_0&cls=WindowsDebugger
>> {"args":{"Executable":"mspaint.exe","Arguments":"fuzzed.png","WinDbgPath":"C:\\Program Files (x86)\\Debugging Tools for Windows (x86)","StartOnCall":"ScoobySnacks"}}
<< { "Status":"true" }

POST /Agent/StartMonitor?name=Monitor_1&cls=PageHeap
>> {"args":{"Executable":"mspaint.exe","WinDbgPath":"C:\\Program Files (x86)\\Debugging Tools for Windows (x86)"}}
<< { "Status":"true" }

GET /Agent/SessionStarting
<< { "Status":"true" }

GET /Agent/IterationStarting?iterationCount=1&isReproduction=False
<< { "Status":"true" }

POST /Agent/Publisher/Set_Iteration
>> {"iteration":1}
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_IsControlIteration
>> {"isControlIteration":true}
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_IsControlIteration
>> {"isControlIteration":true}
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_Iteration
>> {"iteration":1}
<< { "error":"false", "errorString":null }

GET /Agent/Publisher/start
<< { "error":"false", "errorString":null }

GET /Agent/Publisher/open
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/output
>> {"data":"SGVsbG8gV29ybGQ="}
<< { "error":"false", "errorString":null }

GET /Agent/Publisher/close
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/call
>> {"method":"ScoobySnacks","args":[{"name":"p1","data":"SGVsbG8gV29ybGQ=","type":0}]}
<< { "error":"false", "errorString":null }

GET /Agent/IterationFinished
<< { "Status":"true" }

GET /Agent/DetectedFault
<< { "Status":"true" }
// Status of true indicates a fault was detected. False for no fault.

GET /Agent/GetMonitorData
<< {
	"Results":[
		{
			"iteration":0,
			"controlIteration":false,
			"controlRecordingIteration":false,
			"type":0,  (0 unknown, 1 Fault, 2 Data)
			"detectionSource":null,
			"title":null,
			"description":null,
			"majorHash":null,
			"minorHash":null,
			"exploitability":null,
			"folderName":null,
			"collectedData":[
				{"Key":"data1","Value":"AA=="}
			]
		}
	]
}

GET /Agent/IterationStarting?iterationCount=1&isReproduction=True
<< { "Status":"true" }

POST /Agent/Publisher/Set_Iteration
>> {"iteration":1}
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_IsControlIteration
>> {"isControlIteration":true}
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_IsControlIteration
>> {"isControlIteration":true}
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/Set_Iteration
>> {"iteration":1}
<< { "error":"false", "errorString":null }

GET /Agent/Publisher/start
<< { "error":"false", "errorString":null }

GET /Agent/Publisher/open
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/output
>> {"data":"SGVsbG8gV29ybGQ="}
<< { "error":"false", "errorString":null }

GET /Agent/Publisher/close
<< { "error":"false", "errorString":null }

POST /Agent/Publisher/call
>> {"method":"ScoobySnacks","args":[{"name":"p1","data":"SGVsbG8gV29ybGQ=","type":0}]}
<< { "error":"false", "errorString":null }

GET /Agent/IterationFinished
<< { "Status":"true" }

GET /Agent/DetectedFault
<< { "Status":"true" }
// Status of true indicates a fault was detected. False for no fault.

GET /Agent/GetMonitorData
<< {
	"Results":[
		{
			"iteration":0,
			"controlIteration":false,
			"controlRecordingIteration":false,
			"type":0,  (0 unknown, 1 Fault, 2 Data)
			"detectionSource":null,
			"title":null,
			"description":null,
			"majorHash":null,
			"minorHash":null,
			"exploitability":null,
			"folderName":null,
			"collectedData":[
				{"Key":"data1","Value":"AA=="}
			]
		}
	]
}

GET /Agent/Publisher/stop
<< { "Status":"true" }

GET /Agent/SessionFinished
<< { "Status":"true" }

GET /Agent/StopAllMonitors
<< { "Status":"true" }

GET /Agent/AgentDisconnect
<< { "Status":"true" }
----
=========================
