
//
// Copyright (c) Michael Eddington
//
// Permission is hereby granted, free of charge, to any person obtaining a copy 
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights 
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
// copies of the Software, and to permit persons to whom the Software is 
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in	
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

// Authors:
//   Michael Eddington (mike@dejavusecurity.com)

// $Id$

using System;
using System.IO;
using System.Diagnostics;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Reflection;

using Peach.Core;

namespace Peach.Core.Analysis
{
    /// <summary>
    /// Coverage implementation that utalizes PinTools
    /// </summary>
    public class CoverageImpl: Coverage
    {
        string _traceFolder = null;
        bool _needsKilling = false;
		string _pin = "pin\\pin-2.12-54730-msvc10-windows\\pin_bat.bat";

        public CoverageImpl()
        {
            _traceFolder = Guid.NewGuid().ToString();
            while(Directory.Exists(_traceFolder))
                _traceFolder = Guid.NewGuid().ToString();

            Directory.CreateDirectory(_traceFolder);

            if (File.Exists("bblocks.existing"))
                File.Delete("bblocks.existing");
        }

        /// <summary>
        /// Collect all basic blocks in binary
        /// </summary>
        /// <param name="executable"></param>
        /// <returns></returns>
        public override List<ulong> BasicBlocksForExecutable(string executable)
        {
            return null;
        }

        /// <summary>
        /// Perform code coverage based on collection of basic blocks.  If
        /// not provided they will be generated by calling BasicBlocksForExecutable.
        /// </summary>
        /// <param name="executable"></param>
        /// <param name="arguments"></param>
        /// <param name="basicBlocks"></param>
        /// <returns></returns>
        public override List<ulong> CodeCoverageForExecutable(string executable, string arguments, List<ulong> basicBlocks = null)
        {
            try
            {
                if (File.Exists("bblocks.out"))
                    File.Delete("bblocks.out");

                if (basicBlocks != null && basicBlocks.Count > 0)
                {
                    StringBuilder sb = new StringBuilder();
                    foreach (ulong block in basicBlocks)
                        sb.AppendLine(block.ToString());

                    File.WriteAllText("bblocks.existing", sb.ToString());
                }

                var peachBinaries = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);

                var psi = new ProcessStartInfo();
                psi.Arguments = "-t bblocks.dll -- " + executable + " " + arguments;
                psi.FileName = Path.Combine(peachBinaries, _pin);
                psi.CreateNoWindow = true;
                psi.UseShellExecute = true;

                var proc = new Process();
                proc.StartInfo = psi;
                proc.Start();

                if (_needsKilling)
                {
                    // TODO - Check process/cpu usage
                    throw new NotImplementedException();
                }
                else
                {
                    proc.WaitForExit();
                }

                List<ulong> blocks = new List<ulong>();
                using (StreamReader rin = new StreamReader("bblocks.out"))
                {
                    string line = rin.ReadLine();
                    while (!string.IsNullOrEmpty(line))
                    {
						try
						{
							blocks.Add(ulong.Parse(line));
							line = rin.ReadLine();
						}
						catch
						{
							Console.Error.WriteLine("[" + line + "]");
						}
                    }
                }

                return blocks;
            }
            finally
            {
                if (File.Exists("bblocks.out"))
                    File.Delete("bblocks.out");
            }
        }

		public override void Dispose()
		{
			if (File.Exists("bblocks.existing"))
				File.Delete("bblocks.existing");

			if (_traceFolder != null && Directory.Exists(_traceFolder))
				Directory.Delete(_traceFolder, true);
		}
    }
}
