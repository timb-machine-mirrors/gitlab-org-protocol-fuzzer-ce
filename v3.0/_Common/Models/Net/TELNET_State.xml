<?xml version="1.0" encoding="utf-8"?>
<Peach xmlns="http://peachfuzzer.com/2012/Peach" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://peachfuzzer.com/2012/Peach ../peach.xsd"
       author="Deja Vu Security, LLC" description="Telnet Command Protocol PIT StateModels" version="0.0.2">
	<!-- Copyright (c) Deja Vu Security, LLC 2013 -->
	
	<Include ns="DataModels" src="file:##Path##/_Common/Models/Net/TELNET_Data.xml"/>
	<PythonPath path="##Path##/_Common/Models/Net/"/>
	<Import import="TELNET"/>	

	<StateModel name="HostToAgent" initialState="StartServer">
		<State name="StartServer">
      <Action type="start" publisher="TcpHandler"/>

      <Action type="call" method="launchProgram" publisher="Peach.Agent"/>

      <Action type="accept" publisher="TcpHandler"/>

			<Action name="Next" type="changeState" ref="ServerListen"/>
    </State>
		
		<State name="ServerListen">
			<Action name="TelnetReceive" type="input" publisher="TcpHandler">
				<DataModel ref="DataModels:TelnetSingleOptionCrack"/>
			</Action>
			
			<!--Switches state to SendNeg Opts when no more bytes are left to read-->
			<Action name="Done" type="changeState" ref="SendPrompt" when="StateModel.states['ServerListen'].actions[0].dataModel.find('EmptyPacket') != None"/>
			
			<!--Skips send of reply if Sub Options i sent-->
			<Action name="NoReplyNegOption" type="changeState" ref="ServerListen" when="StateModel.states['ServerListen'].actions[0].dataModel.find('command') == None or int(StateModel.states['ServerListen'].actions[0].dataModel.find('command').DefaultValue) == 0xfa"/>
			
			<Action name="OptionSlurp" type="slurp" valueXpath="//ServerListen//TelnetReceive//optionIds" setXpath="//ServerListen//TelnetRespond//optionIds"/>
			<Action name="CommandSlurp" type="slurp" valueXpath="//ServerListen//TelnetReceive//command" setXpath="//ServerListen//TelnetRespond//command"/>
					
			<Action name="TelnetRespond" type="output" publisher="TcpHandler" onStart="TELNET.process_server_output(self)">
				<DataModel ref="DataModels:TelnetClientReply"/>
			</Action>
			
			<Action name="TelnetSendTermSpeedNeg" type="output" publisher="TcpHandler" when="TELNET.value_needs_reply(self)">
				<DataModel ref="DataModels:SendTermSpeedInit"/>
			</Action>
			
			<Action name="TelnetSendNewEnvirNeg" type="output" publisher="TcpHandler" when="TELNET.value_needs_reply(self)">
				<DataModel ref="DataModels:SendNewEnvirOptInit"/>
			</Action>
		
			<Action name="TelnetSendTermTypeNeg" type="output" publisher="TcpHandler" when="TELNET.value_needs_reply(self)">
				<DataModel ref="DataModels:SendTermTypeInit"/>
			</Action>	
			
			<Action name="Next" type="changeState" ref="ServerListen"/>
		</State>
		
		<State name="SendPrompt">
			<Action name="TelnetSendTermTypeNeg" type="output" publisher="TcpHandler">
				<DataModel ref="DataModels:SendPrompt"/>
			</Action>	
			
			<Action name="TelnetReceive" type="input" publisher="TcpHandler">
				<DataModel ref="DataModels:TelnetSingleOptionCrack"/>
			</Action>
			
			<Action name="Next" type="changeState" ref="ReadData"/>
		</State>
		
		<State name="ReadData">
			<Action name="TelnetReceive" type="input" publisher="TcpHandler">
				<DataModel ref="DataModels:TelnetSingleOptionCrack"/>
			</Action>
			
			<Action name="Done" type="changeState" ref="Done" when="StateModel.states['ReadData'].actions[0].dataModel.find('EmptyPacket') != None"/>
			
			<Action name="TelnetSendTermTypeNeg" type="output" publisher="TcpHandler">
				<DataModel ref="DataModels:SendPrompt"/>
			</Action>	
			
			<Action name="Next" type="changeState" ref="Done"/>
		</State>
		
		<State name="Done">
			<Action type="close" publisher="TcpHandler"/>
			<Action type="call" method="exitProgram" publisher="Peach.Agent"/>
		</State>
	</StateModel>
	
	<!-- Telnet Client State Model -->
  <StateModel name="AgentToHost" initialState="Initial">
		<State name="Initial">
			<Action name="TelnetSendConnect" type="output" publisher="TcpHandler" onStart="TELNET.process_client_output(self)">
        <DataModel ref="DataModels:TelnetConnect"/>
      </Action>
			
			<Action name="NextPacket" type="changeState" ref="ReadInput"/>
		</State>
	
		<State name="ReadInput">
			<Action name="TelnetReceive" type="input" publisher="TcpHandler">
				<DataModel ref="DataModels:TelnetSingleOptionCrack"/>
			</Action>
			
			<!--Switches state to SendNeg Opts when no more bytes are left to read-->
			<Action name="Done" type="changeState" ref="SendNegOpts" when="StateModel.states['ReadInput'].actions[0].dataModel.find('EmptyPacket') != None"/>
			
			<!--Skips send of reply when server sends go ahead for Sub Options-->
			<Action name="NoReplyNegOption" type="changeState" ref="ReadInput" when="StateModel.states['ReadInput'].actions[0].dataModel.find('command') == None or int(StateModel.states['ReadInput'].actions[0].dataModel.find('command').DefaultValue) == 0xfa"/>
			
			<Action name="OptionSlurp" type="slurp" valueXpath="//ReadInput//TelnetReceive//optionIds" setXpath="//TelnetRespond//optionIds"/>
			<Action name="CommandSlurp" type="slurp" valueXpath="//ReadInput//TelnetReceive//command" setXpath="//TelnetRespond//command"/>
			
			<!--Skips send of reply if the option is one that the client initiated-->
			<Action name="SkipSend" type="changeState" ref="ReadInput" when="TELNET.is_client_sent_option(self)"/>
			
			<Action name="TelnetRespond" type="output" publisher="TcpHandler" onStart="TELNET.set_client_opposite(self)">
				<DataModel ref="DataModels:TelnetClientReply"/>
			</Action>
		
			<Action name="NextPacket" type="changeState" ref="ReadInput"/>
		</State>
		
		<State name="SendNegOpts">
			<Action name="TelnetSendWindowNeg" type="output" publisher="TcpHandler">
				<DataModel ref="DataModels:SendWindowNegtiate"/>
			</Action>
			
			<Action name="TelnetSendTermSpeedNeg" type="output" publisher="TcpHandler">
				<DataModel ref="DataModels:SendTermSpeed"/>
			</Action>
			
			<Action name="TelnetSendNewEnvirNeg" type="output" publisher="TcpHandler">
				<DataModel ref="DataModels:SendNewEnvirOpt"/>
			</Action>
		
			<Action name="TelnetSendTermTypeNeg" type="output" publisher="TcpHandler">
				<DataModel ref="DataModels:SendTermType"/>
			</Action>	
			
			<!--Rests the data store and changes state to GetConsole-->
			<Action name="Login" type="changeState" ref="GetConsole" when="TELNET.clear_store(self)"/>
		</State>
		
		<State name="GetConsole">
			<Action name="TelnetReceive" type="input" publisher="TcpHandler">
				<DataModel ref="DataModels:TelnetSingleOptionCrack"/>
			</Action>
			
			<!--Changes state to SenPayload when data is received that isn't an opcode-->
			<Action name="GetPrompt" type="changeState" ref="SendPayload" when="StateModel.states['GetConsole'].actions[0].dataModel.find('ReadOne') != None"/>
			
			<!--Switches state to Done Opts when no more bytes are left to read. Ends Iteration-->
			<Action name="Done" type="changeState" ref="Done" when="StateModel.states['GetConsole'].actions[0].dataModel.find('EmptyPacket') != None"/>

			<Action name="OptionSlurp" type="slurp" valueXpath="//GetConsole//TelnetReceive//optionIds" setXpath="//GetConsole//TelnetRespond//optionIds"/>
			<Action name="CommandSlurp" type="slurp" valueXpath="//GetConsole//TelnetReceive//command" setXpath="//GetConsole//TelnetRespond//command"/>
			
			<!--Skips send of reply if the option is one that the client initiated-->
			<Action name="SkipSend" type="changeState" ref="GetConsole" when="TELNET.is_client_sent_option(self)"/>
			
			<Action name="TelnetRespond" type="output" publisher="TcpHandler" onStart="TELNET.store_and_set_opposite(self)">
				<DataModel ref="DataModels:TelnetClientReply"/>
			</Action>
			
			<!--Loops back to the GetConsole to read more data-->
			<Action name="GetConsoleLoop" type="changeState" ref="GetConsole"/>
		</State>
		
		<State name="SendPayload">
			<Action name="TelnetSendPayload" type="output" publisher="TcpHandler">
				<DataModel ref="DataModels:TelnetSendPayload"/>
			</Action>
			
			<Action name="TelnetReceive" type="input" publisher="TcpHandler">
				<DataModel ref="DataModels:TelnetSingleOptionCrack"/>
			</Action>
			
			<Action name="TelnetSendPayload" type="output" publisher="TcpHandler">
				<DataModel ref="DataModels:TelnetSendPayload2"/>
			</Action>
			
			<Action name="TelnetReceive" type="input" publisher="TcpHandler">
				<DataModel ref="DataModels:TelnetSingleOptionCrack"/>
			</Action>
			
			<Action name="TelnetSendPayload" type="output" publisher="TcpHandler">
				<DataModel ref="DataModels:TelnetSendPayload3"/>
			</Action>
		</State>
		
		<!--Empty state that ends the iteration-->
		<State name="Done"/>
	</StateModel>
</Peach>
<!--END-->