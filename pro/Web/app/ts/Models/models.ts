/// <reference path="../../../Scripts/typings/jquery/jquery.d.ts" />

module DashApp.Models {
	"use strict";

	//#region Wizard Models
	export class Question {
		id: number;

		q: string;
		qref: string;

		type: string;

		choice: Choice[];

		shortName: string;

		key: string;
		next: number;

		required: boolean = true;
		value: any;

		defaults: any[] = [];

		rangeMin: number;
		rangeMax: number;

		constructor(question?: Question) {
			if (question != undefined) {
				this.id = question.id;
				this.q = question.q;
				this.qref = question.qref;
				this.type = question.type;
				this.choice = question.choice;
				this.shortName = question.shortName;
				this.key = question.key;
				this.value = question.value;
				this.defaults = question.defaults;
				this.rangeMin = question.rangeMin;
				this.rangeMax = question.rangeMax;
				this.next = question.next;
				if (question.required != undefined) {
					this.required = question.required;
				}
			}
		}

		public static CreateQA(questions: Question[]): Question[] {
			var output: Question[] = [];
			for (var q = 0; q < questions.length; q++) {
				output.push(new Question(questions[q]));
			}
			return output;
		}
	}

	export interface Choice {
		value: any;
		a: string;
		next: number;
	}

	export class StateBag {
		private items: StateItem[] = [];

		constructor(stuff?: StateItem[]) {
			if (stuff != undefined) {
				this.items = stuff;
			}
		}

		public s(name: string, value: any) {
			if (this.containsKey(name))
			{
				var index = this.getIndex(name);
				this.items[index].value = value;
			}
			else
				this.items.push(new StateItem(name, value));
		}

		public g(name: string): any {
			if (this.containsKey(name))
				return this.getItem(name).value;
			else
				return undefined;
		}

		public r(name: string): void {
			var i = this.getIndex(name);
			if(i >= 0) {
				this.items.splice(i, 1);
			}
		}

		public containsKey(name: string): boolean {
			var result = this.getIndex(name);
			return (result != undefined);
		}
		
		private getItem(name: string): StateItem {
			return $.grep(this.items, (e: StateItem) => { return e.key == name; })[0];
		}

		private getIndex(name: string): number {
			for (var i = 0; i < this.items.length; i++) {
				if (this.items[i].key == name)
					return i;
			}
			return undefined;
		}
	}

	export class StateItem {
		key: string;
		value: any;

		constructor(key: string, value: any) {
			this.key = key;
			this.value = value;
		}
	}

	export class Agent {
		agentUrl: string = "";
		monitors: Monitor[] = [];
		description: string = "";
		name: string = "";
 	}

	export interface Monitor {
		monitorClass: string;
		path: number[];
		map: ParameterMap[];
		description: string;
		name: string;
	}

	export interface ParameterMap {
		key: string;
		param: string;
		type: string; 
		value: any; 
		enumValues: string[];
		required: boolean;
	}

	export class QuestionTypes {
		static String = "string";
		static HexString = "hex";
		static Number = "int";
		static Range = "range";
		static IPV4 = "ipv4";
		static IPV6 = "ipv6"; 
		static MACAddress = "hwaddr";
		static NetworkInterface = "iface";
		static OnCall = "oncall";
		static Choice = "choice";
		static Jump = "jump";
		static Intro = "intro";
		static Done = "done";
	}
	//#endregion

	//#region Peach Models 
	export interface Job {

		// URL to configured pit
		///p/pits/ID
		pitUrl: string;

		jobUrl?: string;

		status?: string;

		// all faults generated by this job
		// "/p/jobs/0123456789AB/faults"
		faultsUrl?: string;

		// target we are fuzzing
		targetUrl?: string;

		// target configuration being used
		targetConfigUrl?: string;

		// fuzzing nodes used by job
		// "/p/jobs/0123456789AB/nodes";
		nodesUrl?: string;

		// version of peach used by job, fully qualified
		peachUrl?: string;

		//"/p/files/ID",
		reportUrl?: string;

		// grid fs url to package
		// "/p/files/...",
		packageFileUrl?: string;

		// display name for job
		// "0123456789AB"
		name?: string;

		// ":"notes from user about job, optional",
		notes?: string;

		// Set to null for now
		user?: string;

		//31337,
		seed?: number;

		// current iteration count
		iterationCount?: number;

		startDate?: Date;
		stopDate?: Date;

		// seconds we have been running
		runtime?: number;

		// iterations per hour
		speed?: number;

		// total number of faults
		faultCount?: number;

		// Always 1
		nodeCount?: number;

		// Set to 127.0.0.1
		ipAddress?: string;

		// Empty list
		tags?: Tag[];

		groups?: any[];

		rangeStart?: number;
		rangeStop?: number;

		hasMetrics?: boolean;

		// Optional field. We can set this to null for now
		//"/p/targets/targetID/configs/configID",
		//configUrl: string;

		// Optional field. We can set this to null for now
		//"/p/samples/ID"
		//sampleDataUrl: string;

	}

	export class JobStatuses {
		public static StartPending: string = "startPending";
		public static Running: string = "running";
		public static PausePending: string = "pausePending";
		public static Paused: string = "paused";
		public static ContinuePending: string = "continuePending";
		public static StopPending: string = "stopPending";
		public static Stopped: string = "stopped";

		public static ActionPending: string = "actionPending";
	}

	export interface Tag {
		name: string;
		values: string[];
	}

	export interface PitLibrary {
		libraryUrl: string;
		name: string;
		description: string;
		locked: boolean;
		versions: PitLibraryVersion[];
		groups: Group[];
		user: string;
		timeStamp: Date;
	}

	export interface PitLibraryVersion {
		version: number;
		locked: boolean;
		pits: Pit[];
		//user: string;
		//timeStamp: Date;
	}

	export class Pit {
		pitUrl: string;
		name: string;
		description: string;
		tags: Tag[];
		locked: boolean;

		versions: PitVersion[];

		public get configured(): boolean {
			if (this.hasVersion == false) {
				this.addVersion();
			}

			return this.versions[this.versions.length - 1].configured;
		}

		public set configured(value: boolean) {
			if (this.hasVersion == false) {
				this.addVersion();
			}
			this.versions[this.versions.length - 1].configured = value;
		}

		constructor(pit?: Pit) {
			if (pit != undefined) {
				this.pitUrl = pit.pitUrl;
				this.name = pit.name;
				this.description = pit.description;
				this.tags = pit.tags;
				this.locked = pit.locked;

				if (pit.versions == undefined) {
					this.addVersion();
				} else {
					this.versions = pit.versions;
				}
			}
		}

		private addVersion() {
			var v: PitVersion = {
				locked: false,
				configured: false,
				version: 0
			}
			if (this.versions == undefined) {
				this.versions = [];
			}
			this.versions.push(v);
		}

		public get hasVersion(): boolean {
			return ((this.versions != undefined) && (this.versions.length > 0))
		}
	}

	export interface PitVersion {
		version: number;
		configured: boolean;
		locked: boolean;
	}

	export interface CopyPitRequest {

		// Url of the destination Pit Library
		libraryUrl: string;

		// Pit record. Use only pitUrl, name, and description
		pit: Pit;
	}

	export interface Group {
		groupUrl: string;
		access: string;
	}

	export class PitConfig {
		pitUrl: string;
		config: PitConfigItem[] = [];
		private _keys: string[] = [];
		private _kvps: any[] = [];
		private inttypes: string[] = [QuestionTypes.Number, QuestionTypes.Range];

		constructor(data: PitConfig) {
			this.pitUrl = data.pitUrl;
			this.config = data.config;

			for (var i = 0; i < this.config.length; i++) {
				this._keys.push(this.config[i].key);
				var kvp = { key: this.config[i].key, value: this.config[i].value };
				this._kvps.push(kvp);
			}
		}

		public LoadValuesFromStateBag(stateBag: StateBag) {
			for (var i = 0; i < this.config.length; i++) {
				var key = this.config[i].key;
				if (this.inttypes.indexOf(this.config[i].type) >= 0) {
					this.config[i].value = (<number>stateBag.g(key)).toString();
				} else {
					this.config[i].value = stateBag.g(key);
				}
			}
		}

		public ToQuestions(): Question[] {
			var output: Question[] = [];

			var question: Question = new Question();
			question.id = 0;
			question.type = QuestionTypes.Intro;
			question.qref = "../partials/setvars-intro.html";
			question.next = 1;
			output.push(question);

			for (var i = 0; i < this.config.length; i++) {
				question = new Question();
				question.id = i + 1;
				question.key = this.config[i].key;
				question.shortName = this.config[i].name;

				if (this.config[i].description !== undefined) {
					question.q = this.config[i].description;
				}

				question.key = this.config[i].key;
				question.type = this.config[i].type;
				if (this.inttypes.indexOf(question.type) >= 0) {
					question.value = parseInt(this.config[i].value, 10);
				} else {
					question.value = this.config[i].value;
				}
				question.defaults = this.config[i].defaults;
				question.rangeMax = this.config[i].max;
				question.rangeMin = this.config[i].min;

				if ((i + 1) < this.config.length) {
					question.next = question.id + 1;
				}
				output.push(question);
			}
			return output;
		}

		public containsKey(key: string): boolean {
			return $.grep(this.config, (e) => { return e.key == key; }).length > 0;
		}

		public getValue(key: string) {
			if (this.containsKey(key))
				return $.grep(this.config, (e) => { return e.key == key; })[0].value;
			else
				return undefined;
		}

		public get Keys(): string[] {
			return this._keys;
		}

		public get KeyValuePairs(): any[] {
			return this._kvps;
		}

	}

	export interface PitConfigItem {
		key: string;
		value: any;
		name: string;
		description: string;
		type: string;
		defaults: string[];
		min: number;
		max: number;
	}

	export interface Fault {
		id: string;
		faultUrl: string;
		jobUrl: string;
		targetUrl: string;
		pitUrl: string;
		nodeUrl: string;
		peachUrl: string;
		title: string;
		description: string;
		source: string;
		reproducable: boolean;
		iteration: number;
		seed: number;
		faultType: string;
		exploitability: string;
		majorHash: string;
		minorHash: string;
		folderName: string;
		timeStamp: string;
		bucketName: string;
		files: any[]
	}

	export interface PostMonitorsRequest {
		pitUrl: string;
		monitors: Agent[];
	}

	export interface PostConfigRequest {
		pitUrl: string;
		config: PitConfigItem[];
	}

	export interface StartTestResponse {
		testUrl: string;
	}

	export interface GetTestUpdateResponse {
		status: string;
		log: string;
		events: TestEvent[];
	}

	export interface TestEvent {
		id: number;
		status: string;
		short: string;
		description: string;
		resolve: string;
	}

	//#endregion

	//#region Metrics Models
	export interface FaultTimelineMetric {
		date: Date;
		faultCount: number;
	}

	export interface BucketTimelineMetric {
		id: number;
		label: string;
		iteration: number;
		time: Date;
		faultCount: number;
	}

	export interface MutatorMetric {
		mutator: string;
		elementCount: number;
		iterationCount: number;
		bucketCount: number;
		faultCount: number;
	}

	export interface ElementMetric {
		state: string;
		action: string;
		parameter: string;
		element: string;
		iterationCount: number;
		mutationCount: number;
		bucketCount: number;
		faultCount: number;
	}

	export interface StateMetric {
		state: string;
		executionCount: number;
	}

	export interface DatasetMetric {
		dataset: string;
		iterationCount: number;
		bucketCount: number;
		faultCount: number;
	}

	export interface BucketMetric {
		bucket: string;
		mutator: string;
		dataset: string;
		state: string;
		action: string;
		element: string;
		iterationCount: number;
		faultCount: number;
	}

	export interface VisualizerData {
		iteration: number;
		mutatedElements: string[];
		models: VisualizerModel[];
	}

	export interface VisualizerModel {
		original: string;
		fuzzed: string;
		name: string;
		type: string;
		children: VisualizerModelChild[];
	}

	export interface VisualizerModelChild {
		name: string;
		type: string;
		children: VisualizerModelChild[];
	}
	//#endregion
}