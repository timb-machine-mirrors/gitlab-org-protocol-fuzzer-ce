<?xml version="1.0" encoding="utf-8"?>
<!--
PEACH PIT COPYRIGHT NOTICE AND LEGAL DISCLAIMER

COPYRIGHT
Copyright © 2011-2014 2014 Déjà vu Security, LLC.
All rights reserved.

Déjà vu Security is the sole proprietary owner of Peach Pits and related
definition files and documentation.

User may only use, copy, or modify Peach Pits and related definition files and
documentation for internal business purposes only, provided that this entire
notice and following disclaimer appear in all copies or modifications, and
subject to the following conditions:

(1) User maintains a current subscription to the Peach Pit library.
(2) User's use is restricted to commercially licensed version of Peach Fuzzer
    only. Running Peach Pits with the Peach Fuzzer Community edition or any
    other solution is strictly prohibited.
(3) The sale, transfer, or distribution of Peach Pits and related definition
    files and documentation, in any form, is not permitted, without Déjà vu
    Security's express permission.

Legal Disclaimer
PEACH PITS AND RELATED DEFINTIION FILES AND DOCUMENTATION ARE PROVIDED "AS IS",
DÉJÀ VU SECURITY DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT
NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE. DÉJÀ VU SECURITY HAS NO OBLIGATION TO PROVIDE MAINTENANCE,
SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.

IN NO EVENT SHALL DÉJÀ VU SECURITY BE LIABLE TO ANY PARTY FOR ANY DIRECT,
INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES (INCLUDING LOSS OF USE,
DATA, OR PROFITS), ARISING OUT OF ANY USE OF PEACH PITS AND RELATED
DOCUMENTATION, EVEN IF DÉJÀ VU SECURITY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
-->
<Peach xmlns="http://peachfuzzer.com/2012/Peach"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://peachfuzzer.com/2012/Peach peach.xsd"
       author="Deja Vu Security, LLC"
 description="Transport Control Protocol PIT StateModels" version="0.0.2">

	<Include ns="TCP" src="file:##PitLibraryPath##/_Common/Models/Net/TCP_Data.xml"/>
	<Include ns="TCPv4" src="file:##PitLibraryPath##/_Common/Models/Net/TCPv4_Data.xml"/>
	<PythonPath path="##PitLibraryPath##/_Common/Models/Net/"/>
	<Import import="TCP"/>
	<Import import="code"/>

	<!-- Implements: RFC 793 (http://tools.ietf.org/html/rfc793) -->
	<!-- Currenlty supports fuzzing a listener, not acting as a listener -->


	<StateModel name="Listener" initialState="Initial">

		<State name="Initial">
			<Action type="call" method="StartIterationEvent" publisher="Peach.Agent" />
			<Action type="changeState" ref="SendSyn" />
		</State>

		<State name="SendSyn" >
			<!-- http://tools.ietf.org/html/rfc793#section-3.4 -->
			<!-- Does not support sync connections or half-open recovery -->
			<Action type="output"
							onStart="TCP.init_seq(Context, self)"
							onComplete="TCP.set_next_seq(self)">
				<Data ref="TCP:SYN"/>
				<DataModel name="Packet" ref="TCPv4:Packet"/>
			</Action>
			<Action name="Read" type="changeState" ref="SynWait" />
			<!-- Listener can respond with either a SYN or a SYN,ACK -->
		</State>

		<State name="SynWait">
			<Action name="GetPacket" type="input"
							onComplete="TCP.store_next_acknum(self)">
				<DataModel name="Packet" ref="TCPv4:InIPv4Packet"/>
			</Action>

			<!-- If the listener responds to the inital SYN with a SYN,ACK
			     then we're in SYN RCVD. We need to ACK the SYN,ACK.  -->
			<Action name="GoToSynRecieved"
							type="changeState" ref="SynRecieved"
							when="TCP.get_if_ack_for_me(self.parent.actions[0].dataModel) and bool(int(self.parent.actions[0].dataModel.find('SYN').InternalValue))"/>

			<!-- If the listener responds to the inital SYN with a ACK then
			     we're in SYN SENT. We need to ACK the SYN -->
			<Action name="GoToSynSent"
							type="changeState" ref="SynSent"
							when="TCP.get_if_ack_for_me(self.parent.actions[0].dataModel) and not bool(int(self.parent.actions[0].dataModel.find('SYN').InternalValue))"/>
			
			<Action name="ReadMore" type="changeState" ref="SynWait" />
		</State>

		<State name="SynSent" >
			<Action name="SendAck" type="output"
							onStart="TCP.sync_from_store(self)" >
				<Data ref="TCP:SYNACK"/>
				<DataModel name="Packet" ref="TCPv4:Packet"/>
			</Action>
			<Action type="changeState" ref="SynAckWait"/>
		</State>

		<State name="SynAckWait">
			<Action name="GetPacket" type="input"
							onComplete="TCP.store_next_acknum(self)">
				<DataModel name="Packet" ref="TCPv4:InIPv4Packet"/>
			</Action>
			<Action name="GoToEstablished"
							type="changeState" ref="Established"
							when="TCP.get_if_ack_for_me(self.parent.actions[0].dataModel) and not bool(int(self.parent.actions[0].dataModel.find('SYN').InternalValue))"/>
			<Action name="ReadMore" type="changeState" ref="SynAckWait" />
		</State>

		<State name="SynRecieved" >
			<Action name="SendAck" type="output"
							onStart="TCP.sync_from_store(self)" >
				<Data ref="TCP:ACK"/>
				<DataModel name="Packet" ref="TCPv4:Packet"/>
			</Action>
			<Action type="changeState" ref="Established"/>
		</State>

		<State name="SendFinAck" >
			<Action name="SendAck" type="output"
							onStart="TCP.sync_from_store(self)">
				<Data ref="TCP:ACK"/>
				<DataModel name="Packet" ref="TCPv4:Packet"/>
			</Action>
			<Action type="changeState" ref="SendTestPayload"/>
		</State>

		<!--
		Connection is established:
		
			1. Ready any outstanding data from the client.
			2. Goto send packet
			
		-->
		
		<State name="Established">
			
			<Action name="Receive" type="input"
					onStart="TCP.enableZeroRead(Context)" 
					onComplete="TCP.disableZeroRead(Context)">
				<DataModel name="Packet" ref="TCPv4:InIPv4PacketOrNone"/>
			</Action>
			
			<Action name="Loop" type="changeState"
					ref="Established"
					when="TCP.store_next_acknum(self.parent.actions['Receive'])" />

			<Action name="GoToSendFinAck" type="changeState"
					ref="SendFinalFinAck"
			 		when="TCP.is_fin_ack(self.parent.actions['Receive'].dataModel) and TCP.store_next_acknum(self.parent.actions['Receive'])"/>
			
			<!-- Send Ack, send message -->
			<Action name="SendAck" type="output"
							onStart="TCP.sync_from_lastack(self) and TCP.sync_from_store(self)"
							when="not self.parent.actions['Receive'].dataModel.find('InIPv4Packet')">
				<Data ref="TCP:ACK" />
				<DataModel name="Packet" ref="TCPv4:Packet"/>
			</Action>

			<Action name="SendTestPayload" type="changeState" ref="SendTestPayload" />

		</State>

		<State name="WaitServerClose">
			<Action name="GetPacket" type="input"
							onComplete="TCP.store_next_acknum(self)">
				<DataModel name="Packet" ref="TCPv4:InIPv4Packet"/>
			</Action>
			<Action name="GoToSendTestPayload"
							type="changeState" ref="SendTestPayloadToClosedServer"
							when="TCP.get_if_ack_for_me(self.parent.actions[0].dataModel) and bool(int(self.parent.actions[0].dataModel.find('FIN').InternalValue))"/>
			<Action  name="ReadMore" type="changeState" ref="WaitServerClose" />
		</State>

		<State name="SendTestPayloadToClosedServer" >
			<Action type="output"
							onStart="TCP.sync_from_store(self)"
							onComplete="TCP.set_next_seq(self)">
				<Data ref="TCP:PSHACK"/>
				<DataModel name="PSHPacket" ref="TCPv4:PacketWithData"/>
			</Action>
			<Action name="GoToClose" type="changeState" ref="SyncClose" />
		</State>

		<State name="SendTestPayload" >
			<Action type="output"
							onStart="TCP.sync_from_store(self)"
							onComplete="TCP.set_next_seq(self)">
				<Data ref="TCP:PSHACK"/>
				<DataModel name="PSHPacket" ref="TCPv4:PacketWithData"/>
			</Action>
			<Action name="Read" type="changeState" ref="WaitForAck" />
		</State>

		<State name="WaitForAck">
			<Action name="GetPacket" type="input">
				<DataModel name="Packet" ref="TCPv4:InIPv4Packet"/>
			</Action>

			<Action name="GoToSendFinalAck"
							type="changeState" ref="SendFinalFinAck"
							when="TCP.is_fin_ack(self.parent.actions[0].dataModel) and TCP.store_next_acknum(self.parent.actions[0])"/>
			
			<Action name="GoToClose"
							type="changeState" ref="BeginClose"
							when="TCP.get_if_ack_for_me(self.parent.actions[0].dataModel)"/>
			
			<Action  name="Loop" type="changeState" ref="WaitForAck" 
					 onStart="TCP.store_next_acknum(self.parent.actions[0])"/>
		</State>

		<!-- http://tools.ietf.org/html/rfc793#section-3.5 -->
		<State name="BeginClose" >
			<!-- <Action type="changeState" ref="ImmediateClose"/> -->
			<Action type="changeState" ref="Close"/>
		</State>

		<State name="SyncClose">
			<Action name="Close" type="output"
							onStart="TCP.sync_from_store(self)">
				<Data ref="TCP:FINACK"/>
				<DataModel name="Packet" ref="TCPv4:Packet"/>
			</Action>

			<Action type="call" method="ExitIterationEvent" publisher="Peach.Agent" />
		</State>

		<State name="ImmediateClose">
			<Action name="Close" type="output"
							onStart="TCP.sync_from_store(self)"
							onComplete="TCP.set_next_seq(self)">
				<Data ref="TCP:FINACK"/>
				<DataModel name="Packet" ref="TCPv4:Packet"/>
			</Action>
			<Action name="GoToWaitForAck" type="changeState" ref="WaitForAck"/>
		</State>

		<State name="Close">

			<Action name="Receive" type="input"
					onStart="TCP.enableZeroRead(Context)" 
					onComplete="TCP.disableZeroRead(Context)">
				<DataModel name="Packet" ref="TCPv4:InIPv4PacketOrNone"/>
			</Action>
			
			<Action name="Loop" type="changeState"
					ref="Established"
					when="TCP.store_next_acknum(self.parent.actions['Receive'])" />

			<Action name="GoToSendFinAck" type="changeState"
					ref="SendFinalFinAck"
			 		when="TCP.is_fin_ack(self.parent.actions['Receive'].dataModel)"/>

			<Action name="Close" type="output"
							onStart="TCP.sync_from_store(self)"
							onComplete="TCP.set_next_seq(self)">
				<Data ref="TCP:FINACK"/>
				<DataModel name="Packet" ref="TCPv4:Packet"/>
			</Action>
			
			<Action type="changeState" ref="WaitingForFinAck"/>
		</State>

		<State name="WaitingForFinAck">
			<Action name="GetPacket" type="input"
							onComplete="TCP.store_next_acknum(self)">
				<DataModel name="Packet" ref="TCPv4:InIPv4Packet"/>
			</Action>
			
			<Action name="GoToSend"
							type="changeState" ref="SendFinalFinAck"
							when="TCP.is_fin_ack(self.parent.actions[0].dataModel)"/>
			
			<Action  name="ReadMore" type="changeState" ref="WaitingForFinAck" />
		</State>

		<State name="SendFinalFinAck">
			<Action name="Close" type="output"
							onStart="TCP.sync_from_store(self)">
				<Data ref="TCP:FINACK"/>
				<DataModel name="FINACKPacket" ref="TCPv4:Packet"/>
			</Action>

			<Action type="call" method="ExitIterationEvent" publisher="Peach.Agent" />
		</State>

		<State name="SendFinalAck">
			<Action name="Close" type="output"
							onStart="TCP.sync_from_store(self)">
				<Data ref="TCP:ACK"/>
				<DataModel name="ACKPacket" ref="TCPv4:Packet"/>
			</Action>

			<Action type="call" method="ExitIterationEvent" publisher="Peach.Agent" />
		</State>

		<State name="Recovery">
			<Action name="Close" type="output"
							onStart="TCP.sync_from_store(self)">
				<Data ref="TCP:RST"/>
				<DataModel name="RSTPacket" ref="TCPv4:Packet"/>
			</Action>
			<Action name="TryAgain" type="changeState" ref="SendSyn"/>
		</State>

	</StateModel>
</Peach>
<!--END-->
