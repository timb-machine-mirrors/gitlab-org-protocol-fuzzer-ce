//--------------------------------------
//--- 010 Editor v3.0.2 Binary Template
//
// File: FontTTF.bt
// Author: Michael Eddington
// Revision:
// Purpose: 
//--------------------------------------

// TODO:
//
//  - Debug, some tables not parsing correctly

/*** Endian ***/

BigEndian();

/*** Default Types ***/

typedef struct UINT24
{
    BitfieldDisablePadding();
    uint32  value : 24;
    BitfieldEnablePadding();
};

typedef uint32 Fixed;
typedef short FWORD;
typedef ushort UFWORD;
typedef uint32 F2DOT14;
typedef struct Tag
{
    ubyte   b1;
    ubyte   b2;
    ubyte   b3;
    ubyte   b4;
};

typedef uint16 GlyphID;
typedef uint16 Offset;

typedef int64 LONGDATETIME;

typedef struct OffsetTable
{
    Fixed   sfntVersion;
    USHORT 	numTables;      // 	Number of tables.
    USHORT 	searchRange;    // 	(Maximum power of 2 <= numTables) x 16.
    USHORT 	entrySelector;  // 	Log2(maximum power of 2 <= numTables).
    USHORT 	rangeShift;     // 	NumTables x 16-searchRange.
};

typedef struct TableDirectory
{
    char 	tag[4];        // 	4 -byte identifier.
    ULONG 	checkSum;   // 	CheckSum for this table.
    ULONG 	offset;     // 	Offset from beginning of TrueType font file.
    ULONG 	length;     // 	Length of this table.
};

/**** GLOBAL *****/

local uint32 g_numberOfHMetrics = 0;
local uint32 g_numGlyphs = 0;
local uint32 g_tableDirectory_length;

/**** Common Table definitions *****/

typedef struct ClassDefinitionTable
{
    uint16  ClassFormat;

    switch(ClassFormat)
    {
    case 1:
        GlyphID StartGlyph;
        uint16  GlyphCount;
        uint16  ClassValueArray[GlyphCount];
        break;
    case 2:
        uint16  ClassRangeCount;
        struct
        {
            GlyphID Start;
            GlyphID End;
            uint16  Class;
        } ClassRangeRecord[ClassRangeCount] <optimize=false>;
        break;
    }
};

typedef struct CoverageTable
{
    uint16  CoverageFormat;
    switch(CoverageFormat)
    {
    case 1:
        uint16  GlyphCount;
        GlyphID GlyphArray[GlyphCount];
        break;

    case 2:
        uint16  RangeCount;
        struct RangeRecordTable
        {
            GlyphID Start;
            GlyphID End;
            uint16  StartCoverageIndex;
        } RangeRecord[RangeCount] <optimize=false>;
    }
};

typedef struct DeviceTable
{
    uint16 	StartSize;
    uint16 	EndSize;
    uint16 	DeltaFormat;

    local uint Size;
    Size = EndSize - StartSize;

    Printf("StartSize: %u, EndSize: %u\n", StartSize, EndSize);

    switch(DeltaFormat)
    {
    case 1:
        uint16 	DeltaValue[Size/8];
        break;
    case 2:
        uint16 	DeltaValue[Size/4];
        break;
    case 3:
        uint16 	DeltaValue[Size/2];
        break;
    default:
        Printf("ERROR: DeviceTable: Unknown DeltaFormat: %d\n", DeltaFormat);
        Exit(0);
        break;
    }
};

typedef struct ScriptTable
{
    local uint ScriptTablePos = FTell();
    Printf("ScriptTablePos: %u\n", ScriptTablePos);
    Offset DefaultLangSys;
    uint16  LangSysCount;
    Printf("LangSysCount: %u\n", LangSysCount);

    local uint cnt = 0;
    for(cnt ; cnt < LangSysCount; cnt++)
    {
        struct LangSysRecordTable
        {
            Tag     LangSysTag;
            Offset  LangSys;
    
            Printf("LangSys: %u, New Pos: %u\n", LangSys, ScriptTablePos+LangSys);
    
            local uint PrePos = FTell();
            FSeek(ScriptTablePos+LangSys);
            struct LangSysTable
            {
                Offset 	LookupOrder;
                uint16 	ReqFeatureIndex;
                uint16 	FeatureCount;
                uint16 	FeatureIndex[FeatureCount];
            } langSysTable;

            FSeek(PrePos);

        } langSysRecordTable;
    }

    if(DefaultLangSys != 0)
    {
        FSeek(ScriptTablePos+DefaultLangSys);
        struct LangSysTable defaultLangSysTable;
    }
};

typedef struct ScriptListTable
{
    local uint  ScriptListTablePos = FTell();
    uint16  ScriptCount;

    struct ScriptRecordTable
    {
        Tag     ScriptTag;
        Offset  Script;
    
        FSeek(ScriptListTablePos+Script);
        ScriptTable scriptTable;
    } ScriptRecord[ScriptCount] <optimize=false>;
};

typedef struct FeatureListTable
{
    local uint  FeatureListTablePos = FTell();
    local uint pos;

    uint16  FeatureCount;
    struct FeatureRecordTable
    {
        Tag     FeatureTag;
        Offset  Feature;

        pos = FTell();
        FSeek(FeatureListTablePos+Feature);
        struct FeatureTable
        {
            Offset FeatureParams;
            uint16  LookupCount;
            uint16  LookupListIndex[LookupCount];
        } featureTable;

        FSeek(pos);
    } FeatureRecord[FeatureCount] <optimize=false>;
};

local uint g_PosTablePos;
local uint g_ValueRecordFormat;
typedef struct ValueRecord
{
    if(g_ValueRecordFormat & 0x1)
    {
        int16 	XPlacement;
    }
    if(g_ValueRecordFormat & 0x2)
    {
        int16 	YPlacement;
    }
    if(g_ValueRecordFormat & 0x4)
    {
        int16 	XAdvance;
    }
    if(g_ValueRecordFormat & 0x8)
    {
        int16 	YAdvance;
    }
    if(g_ValueRecordFormat & 0x10)
    {
        Offset 	XPlaDevice;
    
        if(XPlaDevice != 0)
        {
            FSeek(g_PosTablePos+XPlaDevice);
            DeviceTable xPlaDevice;
        }
    }
    if(g_ValueRecordFormat & 0x20)
    {
        Offset 	YPlaDevice;
    
        if(YPlaDevice != 0)
        {
            FSeek(g_PosTablePos+YPlaDevice);
            DeviceTable yPlaDevice;
        }
    }
    if(g_ValueRecordFormat & 0x40)
    {
        Offset 	XAdvDevice;
    
        if(XAdvDevice != 0)
        {
            FSeek(g_PosTablePos+XAdvDevice);
            DeviceTable xAdvDevice;
        }
    }
    if(g_ValueRecordFormat & 0x80)
    {
        Offset 	YAdvDevice;
    
        if(YAdvDevice != 0)
        {
            FSeek(g_PosTablePos+YAdvDevice);
            DeviceTable yAdvDevice;
        }
    }
};

typedef struct AnchorTable
{
    local uint AnchorTablePos = FTell();
    uint16 	AnchorFormat;
    switch(AnchorFormat)
    {
    case 1:
        int16 	XCoordinate;
        int16 	YCoordinate;
        break;
    case 2:
        int16 	XCoordinate;
        int16 	YCoordinate;
        uint16 	AnchorPoint;
        break;
    case 3:
        int16 	XCoordinate;
        int16 	YCoordinate;
        Offset 	XDeviceTable;
        Offset 	YDeviceTable;

        if(XDeviceTable != 0)
        {
            FSeek(AnchorTablePos+XDeviceTable);
            DeviceTable xDeviceTable;
        }

        if(YDeviceTable != 0)
        {
            FSeek(AnchorTablePos+YDeviceTable);
            DeviceTable yDeviceTable;
        }
        break;
    default:
        // ERROR
        Printf("ERROR: Unknown AnchorFormat: %u\n", AnchorFormat);
        Exit(1);
    }
};

typedef struct MarkArrayTable
{
    local uint MarkArrayTable = FTell();
    uint16  MarkCount;

    Printf("MarkArrayTablePos: %u, MarkCount: %u\n", MarkArrayTable, MarkCount);

    struct MarkRecord
    {
        uint16  Class;
        Offset  MarkAnchor;

        Printf("MarkAnchor Pos: %u, New Pos: %u\n", MarkAnchor, MarkArrayTable+MarkAnchor);

        FSeek(MarkArrayTable+MarkAnchor);
        AnchorTable markAnchor;
    } markRecord[MarkCount] <optimize=false>;
};

typedef struct PosLookupRecordTable
{
    uint16 	SequenceIndex;
    uint16 	LookupListIndex;
};

typedef struct LookupListTable
{
    local uint  LookupListTablePos = FTell();
    uint16  LookupCount;
    Offset  Lookup[LookupCount];

    local int i;
    for(i = 0; i<LookupCount; i++)
    {
        FSeek(LookupListTablePos + Lookup[i]);
        struct LookupTable
        {
            local uint LookupTablePos = FTell();
            uint16 	LookupType;
            uint16 	LookupFlag;
            uint16 	SubTableCount;
            Offset 	SubTable[SubTableCount];
            
            local int x;
            for(x = 0; x<SubTableCount; x++)
            {
                g_PosTablePos = LookupTablePos + SubTable[x];
                FSeek(g_PosTablePos);

                struct SubTable
                {
                    switch(LookupType)
                    {
                    case 1:
                        uint16 	PosFormat;
                        switch(PosFormat)
                        {
                        case 1:
                            Offset 	Coverage;
                            uint16 	ValueFormat;
                            ValueRecord 	Value;
                            break;

                        case 2:
                            Offset 	Coverage;
                            uint16 	ValueFormat;
                            uint16 	ValueCount;
                            ValueRecord 	Value[ValueCount] <optimize=false>;
                            break;
                        }
                    
                        FSeek(g_PosTablePos+Coverage);
                        CoverageTable coverageTable;
                        break;

                    case 2:
                        uint16 	PosFormat;
                        switch(PosFormat)
                        {
                        case 1:
                            Offset 	Coverage;
                            uint16 	ValueFormat1;
                            uint16 	ValueFormat2;
                            uint16 	PairSetCount;
                            Offset 	PairSetOffset[PairSetCount];
                            
                            local int j;
                            for(j = 0; j<PairSetCount; j++)
                            {
                                FSeek(g_PosTablePos+PairSetOffset[j]);
                                struct PairSetTable
                                {
                                    uint16  PairValueCount;
                                    struct PairValueRecord
                                    {
                                        GlyphID SecondGlyph;
                                        g_ValueRecordFormat = ValueFormat1;
                                        ValueRecord value1;
                                        g_ValueRecordFormat = ValueFormat2;
                                        ValueRecord value2;
                                    } pairValueRecord[PairValueCount] <optimize=false>;
                                } pairSetTable;
                            }
                            break;

                        case 2:
                            Offset 	Coverage;
                            uint16 	ValueFormat1;
                            uint16 	ValueFormat2;
                            Offset 	ClassDef1;
                            Offset 	ClassDef2;
                            uint16 	Class1Count;
                            uint16 	Class2Count;
                            struct 	Class1Record
                            {
                                struct Class2Record
                                {
                                    g_ValueRecordFormat = ValueFormat1;
                                    ValueRecord Value1;
                                    g_ValueRecordFormat = ValueFormat2;
                                    ValueRecord Value2;
                                } class2Record[Class2Count] <optimize=false>;
                            } class1Record[Class1Count] <optimize=false>;

                            FSeek(g_PosTablePos+ClassDef1);
                            ClassDefinitionTable classDef1;

                            FSeek(g_PosTablePos+ClassDef2);
                            ClassDefinitionTable classDef2;
                            break;
                        default:
                            Printf("Failure! 446");
                            Exit(1);
                        }
                    
                        FSeek(g_PosTablePos+Coverage);
                        CoverageTable coverageTable;
                        break;

                    case 3:
                        uint16 	PosFormat;
                        Offset 	Coverage;
                        uint16 	EntryExitCount;
                        struct 	EntryExitRecord
                        {
                            Offset  EntryAnchor;
                            Offset  ExitAnchor;
                    
                            if(EntryAnchor != 0)
                            {
                                FSeek(g_PosTablePos+EntryAnchor);
                                AnchorTable entryAnchor;
                            }

                            if(ExitAnchor != 0)
                            {
                                FSeek(g_PosTablePos+ExitAnchor);
                                AnchorTable exitAnchor;
                            }
                        } entryExitRecord[EntryExitCount] <optimize=false>;
                    
                        FSeek(g_PosTablePos+Coverage);
                        CoverageTable coverageTable;
                        break;

                    case 4:
                        uint16 	PosFormat;
                        Offset 	MarkCoverage;
                        Offset 	BaseCoverage;
                        uint16 	ClassCount;
                        Offset 	MarkArray;
                        Offset 	BaseArray;

                        FSeek(g_PosTablePos+MarkCoverage);
                        CoverageTable markCoverage;
                        FSeek(g_PosTablePos+BaseCoverage);
                        CoverageTable baseCoverage;

                        FSeek(g_PosTablePos+MarkArray);
                        MarkArrayTable markArray;

                        FSeek(g_PosTablePos+BaseArray);
                        struct BaseArrayTable
                        {
                            uint16  BaseCount;
                            struct BaseRecord
                            {
                                Offset BaseAnchor[ClassCount];
                                local int r;
                                for(r = 0; r<ClassCount; r++)
                                {
                                    FSeek(g_PosTablePos+BaseArray+BaseAnchor[r]);
                                    AnchorTable baseAnchor;
                                }
                            } baseRecord[BaseCount] <optimize=false>;
                        } baseArrayTable;

                        FSeek(g_PosTablePos+Coverage);
                        CoverageTable coverageTable;
                        break;

                    case 5:
                        uint16 	PosFormat;
                        Offset 	MarkCoverage;
                        Offset 	LigatureCoverage;
                        uint16 	ClassCount;
                        Offset 	MarkArray;
                        Offset 	LigatureArray;

                        FSeek(g_PosTablePos+MarkArray);
                        MarkArrayTable markArray;

                        FSeek(g_PosTablePos+LigatureArray);
                        struct LigatureArrayTable
                        {
                            uint16  LigatureCount;
                            Offset  LogatureAttach[LogatureCount];

                            local int r;
                            for(r = 0; r<ClassCount; r++)
                            {
                                FSeek(g_PosTablePos+LigatureArray+LogatureAttach[r]);
                                struct LigatureAttachTable
                                {
                                    uint16 ComponentCount;
                                    struct ComponentRecord
                                    {
                                        Offset LigatureAnchor[ClassCount];

                                        local int y;
                                        for(y = 0; y<ClassCount; y++)
                                        {
                                            FSeek(g_PosTablePos+LigatureArray+LogatureAttach[r]+LigatureAnchor[y]);
                                            AnchorTable ligatureAnchor;
                                        }
                                    } componentRecord[ComponentCount] <optimize=false>;
                                } ligatureAttachTable;
                            }
                        } ligatureArrayTable;

                        FSeek(g_PosTablePos+MarkCoverage);
                        CoverageTable markCoverage;

                        FSeek(g_PosTablePos+LigatureCoverage);
                        CoverageTable ligatureCoverage;
                        break;

                    case 6:
                        uint16 	PosFormat;
                        Offset 	Mark1Coverage;
                        Offset 	Mark2Coverage;
                        uint16 	ClassCount;
                        Offset 	Mark1Array;
                        Offset 	Mark2Array;

                        FSeek(g_PosTablePos+Mark1Array);
                        MarkArrayTable mark1Array;

                        FSeek(g_PosTablePos+Mark2Array);
                        struct Mark2ArrayTable
                        {
                            uint16 Mark2Count;
                            struct Mark2Record
                            {
                                Offset Mark2Anchor[ClassCount];
                                
                                local int r;
                                for(r = 0; r<ClassCount; r++)
                                {
                                    FSeek(g_PosTablePos+Mark2Array+Mark2Anchor[r]);
                                    AnchorTable mark2Anchor;
                                }
                            } mark2Record[Mark2Count] <optimize=false>;
                        } mark2Array;

                        FSeek(g_PosTablePos+Mark1Coverage);
                        CoverageTable mark1Coverage;

                        FSeek(g_PosTablePos+Mark2Coverage);
                        CoverageTable mark2Coverage;
                        break;

                    case 7:
                        uint16 	PosFormat;
                        switch(PosFormat)
                        {
                        case 1:
                            Offset 	Coverage;
                            uint16 	PosRuleSetCount;
                            Offset 	PosRuleSet[PosRuleSetCount];

                            local int j;
                            for(j = 0; j<PosRuleSetCount; j++)
                            {
                                FSeek(g_PosTablePos+PosRuleSet[j]);
                                struct PosRuleSetTable
                                {
                                    uint16  PosRuleCount;
                                    Offset  PosRule[PosRuleCount];
                                
                                    local int r;
                                    for(r = 0; r<ClassCount; r++)
                                    {
                                        FSeek(g_PosTablePos+PosRuleSet[j]+PosRule[r]);
                                        struct PosRuleTable
                                        {
                                            uint16 	GlyphCount;
                                            uint16 	PosCount;
                                            GlyphID Input[GlyphCount - 1];
                                            PosLookupRecordTable posLookupRecord[PosCount] <optimize=false>;
                                        } posRuleTable;
                                    }
                                } posRuleSetTable;
                            }
    
                            FSeek(g_PosTablePos+Coverage);
                            CoverageTable coverage;
                            break;
                        case 2:
                            Offset 	Coverage;
                            Offset 	ClassDef;
                            uint16 	PosClassSetCnt;
                            Offset 	PosClassSet[PosClassSetCnt];

                            FSeek(g_PosTablePos+ClassDef);
                            ClassDefinitionTable classDef;

                            local int j;
                            for(j = 0; j<PosClassSetCnt; j++)
                            {
                                FSeek(LookupTablePos+SubTable[x]+PosClassSet[j]);
                                struct PosClassSetTable
                                {
                                    uint16 PosClassRuleCnt;
                                    struct PosClassRule
                                    {
                                        uint16 	GlyphCount;
                                        uint16 	PosCount;
                                        uint16 	Class[GlyphCount - 1];
                                        PosLookupRecordTable PosLookupRecord[PosCount] <optimize=false>;
                                    } posClassRule[PosClassRuleCnt] <optimize=false>;
                                } posClassSet;
                            }
    
                            FSeek(g_PosTablePos+Coverage);
                            CoverageTable coverage;
                            break;
                        case 3:
                            uint16 	GlyphCount;
                            uint16 	PosCount;
                            Offset 	Coverage[GlyphCount];
                            PosLookupRecordTable PosLookupRecord[PosCount] <optimize=false>;

                            local int j;
                            for(j = 0; j<PosCount; j++)
                            {
                                FSeek(LookupTablePos+SubTable[x]+PosLookupRecord[j]);
                                CoverageTable coverage;
                            }
                            break;
                        default:
                            Printf("Failure 676\n");
                            Exit(1);
                        }
                        break;

                    case 8:
                        uint16 	PosFormat;
                        switch(PosFormat)
                        {
                        case 1:
                            Offset 	Coverage;
                            uint16 	ChainPosRuleSetCount;
                            Offset 	ChainPosRuleSet[ChainPosRuleSetCount];
                        
                            FSeek();
                            struct ChainPosRuleSetTable
                            {
                                uint16  ChainPosRuleCount;
                                Offset  ChainPosRule[ChainPosRuleCount];
                        
                                local int j;
                                for(j = 0; j<ChainPosRuleCount; j++)
                                {
                                    FSeek(LookupTablePos+SubTable[x]+ChainPosRule[j]);
                                    struct ChainPosRuleTable
                                    {
                                        uint16 	BacktrackGlyphCount;
                                        GlyphID 	Backtrack[BacktrackGlyphCount];
                                        uint16 	InputGlyphCount;
                                        GlyphID 	Input[InputGlyphCount - 1];
                                        uint16 	LookaheadGlyphCount;
                                        GlyphID 	LookAhead[LookAheadGlyphCount];
                                        uint16 	PosCount;
                                        PosLookupRecordTable 	PosLookupRecord[PosCount] <optimize=false>;
                                    } chainPosRule;
                                }
                            } chainPosRuleSetTable;
                        
                            FSeek(g_PosTablePos+Coverage);
                            CoverageTable coverage;
                            break;
                        case 2:
                            Offset 	Coverage;
                            Offset 	BacktrackClassDef;
                            Offset 	InputClassDef;
                            Offset 	LookaheadClassDef;
                            uint16 	ChainPosClassSetCnt;
                            Offset 	ChainPosClassSet[ChainPosClassSetCnt];
                            
                            FSeek(LookupTablePos+SubTable[x]+BacktrackClassDef);
                            ClassDefinitionTable backtrackClassDef;
                            FSeek(LookupTablePos+SubTable[x]+InputClassDef);
                            ClassDefinitionTable inputClassDef;
                            FSeek(LookupTablePos+SubTable[x]+LookaheadClassDef);
                            ClassDefinitionTable lookaheadClassDef;
                        
                            local int j;
                            for(j = 0; j<ChainPosClassSetCnt; j++)
                            {
                                FSeek(LookupTablePos+SubTable[x]+ChainPosClassSet[j]);
                                struct ChainPosClassSetTable
                                {
                                    uint16 	ChainPosClassRuleCnt;
                                    Offset 	ChainPosClassRule[ChainPosClassRuleCnt];
                        
                                    local int r;
                                    for(r = 0; r<ChainPosClassRuleCnt; r++)
                                    {
                                        FSeek(LookupTablePos+SubTable[x]+ChainPosClassSet[j]+ChainPosClassRule[r]);
                                        struct ChainPosClassRuleTable
                                        {
                                            uint16 	BacktrackGlyphCount;
                                            uint16 	Backtrack[BacktrackGlyphCount];
                                            uint16 	InputGlyphCount;
                                            uint16 	Input[InputGlyphCount - 1];
                                            uint16 	LookaheadGlyphCount;
                                            uint16 	LookAhead[LookAheadGlyphCount];
                                            uint16 	PosCount;
                                            PosLookupRecordTable 	PosLookupRecord[ChainPosCount] <optimize=false>;
                                        } chainPosClassRuleTable;
                                    }
                                } chainPosClassSetTable;
                            }
                        
                            FSeek(g_PosTablePos+Coverage);
                            CoverageTable coverage;
                            break;
                        case 3:
                            uint16 	BacktrackGlyphCount;
                            Offset 	Coverage1[BacktrackGlyphCount];
                            uint16 	InputGlyphCount;
                            Offset 	Coverage2[InputGlyphCount];
                            uint16 	LookaheadGlyphCount;
                            Offset 	Coverage3[LookaheadGlyphCount];
                            uint16 	PosCount;
                            PosLookupRecordTable 	PosLookupRecord[PosCount] <optimize=false>;
                        
                            local int j;
                            for(j = 0; j<BacktrackGlyphCount; j++)
                            {
                                FSeek(LookupTablePos+SubTable[x]+Coverage1[j]);
                                CoverageTable coverage1;
                            }
                            for(j = 0; j<InputGlyphCount; j++)
                            {
                                FSeek(LookupTablePos+SubTable[x]+Coverage2[j]);
                                CoverageTable coverage2;
                            }
                            for(j = 0; j<LookaheadGlyphCount; j++)
                            {
                                FSeek(LookupTablePos+SubTable[x]+Coverage3[j]);
                                CoverageTable coverage3;
                            }
                            break;
                        default:
                            Printf("Failure 791\n");
                            Exit(1);
                        }
                        break;

                    case 9:
                        USHORT 	PosFormat;
                        USHORT 	ExtensionLookupType;
                        ULONG 	ExtensionOffset;
                        
                        Printf("[!] - Unsupported subtable #9\n");

                        break;
                    default:
                        Printf("Failure 805\n");
                        Exit(1);
                    }
                } subTable;
            }
        } lookupTable;
    }
};

/**** Table definitions *****/

typedef struct CmapTable
{
    // Header
    USHORT 	version;    // 	Table version number (0).
    USHORT 	numTables;  // 	Number of encoding tables that follow.    

    struct 
    {
        USHORT 	platformID; // 	Platform ID.
        USHORT 	encodingID; // 	Platform-specific encoding ID.
        ULONG 	offset;     // 	Byte offset from beginning of table to the subtable for this encoding.
    } encodingRecord[numTables] <optimize=false>;

    local uint32 pos = FTell();
    local uint32 i;

    for(i = 0; i<numTables; i++)
    {
        FSeek(pos + encodingRecord[i].offset);

        switch(encodingRecord[i].encodingID)
        {
        case 0:
            USHORT 	format; // 	Format number is set to 0.
            USHORT 	length; // 	This is the length in bytes of the subtable.
            USHORT 	language; // 	Please see "Note on the language field in 'cmap' subtables" in this document.
            BYTE 	glyphIdArray[256]; // 	An array that maps character codes to glyph index values.
            break;
        case 1:
            USHORT 	format; // 	Format number is set to 2.
            USHORT 	length; // 	This is the length in bytes of the subtable.
            USHORT 	language; // 	Please see "Note on the language field in 'cmap' subtables" in this document.
            USHORT 	subHeaderKeys[256]; // 	Array that maps high bytes to subHeaders: value is subHeader index * 8.
            //4 words struct 	subHeaders[ ]; // 	Variable-length array of subHeader structures.
            //USHORT 	glyphIndexArray[ ]; // 	Variable-length array containing subarrays used for mapping the low byte of 2-byte characters.
            break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
            break;
        default:
            Printf("Failure 863\n"); Exit(1);
        }
    }
};

typedef struct HeadTable
{
    Fixed 	TableVersionNumber; // 	0x00010000 for version 1.0.
    Fixed 	fontRevision; // 	Set by font manufacturer.
    ULONG 	checkSumAdjustment; // 	To compute: set it to 0, sum the entire font as ULONG, then store 0xB1B0AFBA - sum.
    ULONG 	magicNumber; // 	Set to 0x5F0F3CF5.
    USHORT 	flags; // 	Bit 0: Baseline for font at y=0;
        // Bit 1: Left sidebearing point at x=0;
        // Bit 2: Instructions may depend on point size;
        // Bit 3: Force ppem to integer values for all internal scaler math; may use fractional ppem sizes if this bit is clear;
        // Bit 4: Instructions may alter advance width (the advance widths might not scale linearly);
        // Bits 5-10: These should be set according to Apple's specification . However, they are not implemented in OpenType.
        // Bit 11: Font data is 'lossless,' as a result of having been compressed and decompressed with the Agfa MicroType Express engine.
        // Bit 12: Font converted (produce compatible metrics)
        // Bit 13: Font optimized for ClearType™. Note, fonts that rely on embedded bitmaps (EBDT) for rendering should not be considered optimized for ClearType, and therefore should keep this bit cleared.
        // Bit 14: Reserved, set to 0
        // Bit 15: Reserved, set to 0
    USHORT 	unitsPerEm; // 	Valid range is from 16 to 16384. This value should be a power of 2 for fonts that have TrueType outlines.
    LONGDATETIME 	created; // 	Number of seconds since 12:00 midnight, January 1, 1904. 64-bit integer
    LONGDATETIME 	modified; // 	Number of seconds since 12:00 midnight, January 1, 1904. 64-bit integer
    SHORT 	xMin; // 	For all glyph bounding boxes.
    SHORT 	yMin; // 	For all glyph bounding boxes.
    SHORT 	xMax; // 	For all glyph bounding boxes.
    SHORT 	yMax; // 	For all glyph bounding boxes.
    USHORT 	macStyle; // 	Bit 0: Bold (if set to 1);
        // Bit 1: Italic (if set to 1)
        // Bit 2: Underline (if set to 1)
        // Bit 3: Outline (if set to 1)
        // Bit 4: Shadow (if set to 1)
        // Bit 5: Condensed (if set to 1)
        // Bit 6: Extended (if set to 1)
        // Bits 7-15: Reserved (set to 0).
    USHORT 	lowestRecPPEM; // 	Smallest readable size in pixels.
    SHORT 	fontDirectionHint; // 	0: Fully mixed directional glyphs;
        // 1: Only strongly left to right;
        // 2: Like 1 but also contains neutrals;
        // -1: Only strongly right to left;
        // -2: Like -1 but also contains neutrals. 1
    SHORT 	indexToLocFormat; // 	0 for short offsets, 1 for long.
    SHORT 	glyphDataFormat; // 	0 for current format.
};

typedef struct HheaTable
{
    Fixed  	TableVersionNumber; //  	0x00010000 for version 1.0.
    FWORD 	Ascender; // 	Typographic ascent. (Distance from baseline of highest ascender)
    FWORD 	Descender; // 	Typographic descent. (Distance from baseline of lowest descender)
    FWORD 	LineGap; // 	Typographic line gap.
        //Negative LineGap values are treated as zero
        //in Windows 3.1, System 6, and
        //System 7.
    UFWORD 	advanceWidthMax; // 	Maximum advance width value in 'hmtx' table.
    FWORD 	minLeftSideBearing; // 	Minimum left sidebearing value in 'hmtx' table.
    FWORD 	minRightSideBearing; // 	Minimum right sidebearing value; calculated as Min(aw - lsb - (xMax - xMin)).
    FWORD 	xMaxExtent; // 	Max(lsb + (xMax - xMin)).
    SHORT 	caretSlopeRise; // 	Used to calculate the slope of the cursor (rise/run); 1 for vertical.
    SHORT 	caretSlopeRun; // 	0 for vertical.
    SHORT 	caretOffset;    // 	The amount by which a slanted highlight on a glyph needs to be shifted to produce the best appearance. Set to 0 for non-slanted fonts
    SHORT 	reserved1; // 	set to 0
    SHORT 	reserved2; // 	set to 0
    SHORT 	reserved3; // 	set to 0
    SHORT 	reserved4; // 	set to 0
    SHORT 	metricDataFormat; // 	0 for current format.
    USHORT 	numberOfHMetrics; // 	Number of hMetric entries in 'hmtx' table

    g_numberOfHMetrics = numberOfHMetrics;
};

typedef struct 	longHorMetric {
	USHORT	advanceWidth;
	SHORT		lsb;
};

typedef struct HmtxTable
{
    Printf("numGlyphs: %d\n", g_numGlyphs);
    Printf("g_numberOfHMetrics: %d\n", g_numberOfHMetrics);
    longHorMetric hMetrics[g_numberOfHMetrics];    // 	Paired advance width and left side bearing values for each glyph. The value numOfHMetrics comes from the 'hhea' table. If the font is monospaced, only one entry need be in the array, but that entry is required. The last entry applies to all subsequent glyphs.
    SHORT leftSideBearing[g_numGlyphs - g_numberOfHMetrics]; // 	Here the advanceWidth is assumed to be the same as the advanceWidth for the last entry above. The number of entries in this array is derived from numGlyphs (from 'maxp' table) minus numberOfHMetrics. This generally is used with a run of monospaced glyphs (e.g., Kanji fonts or Courier fonts). Only one run is allowed and it must be at the end. This allows a monospaced font to vary the left side bearing values for each glyph.
};

typedef struct MaxpTable
{
    Fixed 	TableVersionNumber; // 	0x00005000 for version 0.5
        //(Note the difference in the representation of a non-zero fractional part, in Fixed numbers.)

    if(TableVersionNumber == 0x00005000)
    {
        USHORT 	numGlyphs; // 	The number of glyphs in the font.
        g_numGlyphs = numGlyphs;
    }
    else
    {
        USHORT 	numGlyphs; // 	The number of glyphs in the font.
        USHORT 	maxPoints; // 	Maximum points in a non-composite glyph.
        USHORT 	maxContours; // 	Maximum contours in a non-composite glyph.
        USHORT 	maxCompositePoints; // 	Maximum points in a composite glyph.
        USHORT 	maxCompositeContours; // 	Maximum contours in a composite glyph.
        USHORT 	maxZones; // 	1 if instructions do not use the twilight zone (Z0), or 2 if instructions do use Z0; should be set to 2 in most cases.
        USHORT 	maxTwilightPoints; // 	Maximum points used in Z0.
        USHORT 	maxStorage; // 	Number of Storage Area locations.
        USHORT 	maxFunctionDefs; // 	Number of FDEFs.
        USHORT 	maxInstructionDefs; // 	Number of IDEFs.
        USHORT 	maxStackElements; // 	Maximum stack depth2.
        USHORT 	maxSizeOfInstructions; // 	Maximum byte count for glyph instructions.
        USHORT 	maxComponentElements; // 	Maximum number of components referenced at "top level" for any composite glyph.
        USHORT 	maxComponentDepth; // 	Maximum levels of recursion; 1 for simple components.
        g_numGlyphs = numGlyphs;
    }
};

typedef struct NameRecord
{
    USHORT  platformID; //  	Platform ID.
    USHORT 	encodingID; // 	Platform-specific encoding ID.
    USHORT 	languageID; // 	Language ID.
    USHORT 	nameID;     // 	Name ID.
    USHORT 	length;     // 	String length (in bytes).
    USHORT 	offset;     // 	String offset from start of storage area (in bytes).
};

typedef struct NameTable
{
    USHORT      format;             //  	Format selector (=0).
    USHORT 	    count;              // 	Number of name records.
    USHORT 	    stringOffset;       // 	Offset to start of string storage (from start of table).
    NameRecord 	nameRecord[count];  // 	The name records where count is the number of records.

    local uint32 pos = FTell();
    local uint32 i;

    for(i = 0; i<count; i++)
    {
        FSeek(pos + nameRecord[i].offset);
        struct {
            char name[nameRecord[i].length] <optimize=false>;
        } name <optimize=false>;
    }
};

typedef struct Os2Table
{
    USHORT 	version; // 	0x0004
    SHORT 	xAvgCharWidth; // 	 
    USHORT 	usWeightClass; // 	 
    USHORT 	usWidthClass; // 	 
    USHORT 	fsType; // 	 
    SHORT 	ySubscriptXSize; // 	 
    SHORT 	ySubscriptYSize; // 	 
    SHORT 	ySubscriptXOffset; // 	 
    SHORT 	ySubscriptYOffset; // 	 
    SHORT 	ySuperscriptXSize; // 	 
    SHORT 	ySuperscriptYSize; // 	 
    SHORT 	ySuperscriptXOffset; // 	 
    SHORT 	ySuperscriptYOffset; // 	 
    SHORT 	yStrikeoutSize; // 	 
    SHORT 	yStrikeoutPosition; // 	 
    SHORT 	sFamilyClass; // 	 
    BYTE 	panose[10]; // 	 
    ULONG 	ulUnicodeRange1; // 	Bits 0-31
    ULONG 	ulUnicodeRange2; // 	Bits 32-63
    ULONG 	ulUnicodeRange3; // 	Bits 64-95
    ULONG 	ulUnicodeRange4; // 	Bits 96-127
    CHAR 	achVendID[4]; // 	 
    USHORT 	fsSelection; // 	 
    USHORT 	usFirstCharIndex; // 	 
    USHORT 	usLastCharIndex; // 	 
    SHORT 	sTypoAscender; // 	 
    SHORT 	sTypoDescender; // 	 
    SHORT 	sTypoLineGap; // 	 
    USHORT 	usWinAscent; // 	 
    USHORT 	usWinDescent; // 	 
    ULONG 	ulCodePageRange1; // 	Bits 0-31
    ULONG 	ulCodePageRange2; // 	Bits 32-63
    SHORT 	sxHeight; // 	 
    SHORT 	sCapHeight; // 	 
    USHORT 	usDefaultChar; // 	 
    USHORT 	usBreakChar; // 	 
    USHORT 	usMaxContext; //
};

typedef struct PostTable
{
    Fixed 	Version; // 	0x00010000 for version 1.0
        //0x00020000 for version 2.0
        //0x00025000 for version 2.5 (deprecated)
        //0x00030000 for version 3.0
    Fixed 	italicAngle; // 	Italic angle in counter-clockwise degrees from the vertical. Zero for upright text, negative for text that leans to the right (forward).
    FWORD 	underlinePosition; // 	This is the suggested distance of the top of the underline from the baseline (negative values indicate below baseline).
        //The PostScript definition of this FontInfo dictionary key (the y coordinate of the center of the stroke) is not used for historical reasons. The value of the PostScript key may be calculated by subtracting half the underlineThickness from the value of this field.
    FWORD 	underlineThickness; // 	Suggested values for the underline thickness.
    ULONG 	isFixedPitch; // 	Set to 0 if the font is proportionally spaced, non-zero if the font is not proportionally spaced (i.e. monospaced).
    ULONG 	minMemType42; // 	Minimum memory usage when an OpenType font is downloaded.
    ULONG 	maxMemType42; // 	Maximum memory usage when an OpenType font is downloaded.
    ULONG 	minMemType1; // 	Minimum memory usage when an OpenType font is downloaded as a Type 1 font.
    ULONG 	maxMemType1; // 	Maximum memory usage when an OpenType font is downloaded as a Type 1 font.

    switch(Version)
    {
    case 0x00020000:
        USHORT 	numberOfGlyphs; // 	Number of glyphs (this should be the same as numGlyphs in 'maxp' table).
        USHORT 	glyphNameIndex[numberOfGlyphs]; //. 	This is not an offset, but is the ordinal number of the glyph in 'post' string tables.
        CHAR 	names[numberOfGlyphs]; // 	Glyph names with length bytes [variable] (a Pascal string).
        break;
    case 0x00025000:
        USHORT 	numberOfGlyphs; // 	Number of glyphs
        CHAR 	offset[numberOfGlyphs];// 	Difference between graphic index and standard order of glyph
        break;
    default:
        Printf("Failure 1077\n"); Exit(1);
    }
};

typedef struct CvtTable
{
    FWORD   values[ g_tableDirectory_length / sizeof(FWORD) ];
};

typedef struct FpgmTable
{
    BYTE   values[ g_tableDirectory_length / sizeof(BYTE) ];
};

typedef struct GlyfTable
{
    local int i;
    for(i = 0; i < 1; i++)
    {
        struct GlyfStuff
        {
            SHORT 	numberOfContours;
            SHORT 	xMin;
            SHORT 	yMin;
            SHORT 	xMax;
            SHORT 	yMax;
        
            if(numberOfContours > 0)
            {
                USHORT 	endPtsOfContours[numberOfContours];// 	Array of last points of each contour; n is the number of contours.
                USHORT 	instructionLength;// 	Total number of bytes for instructions.
                BYTE 	instructions[instructionLength];// 	Array of instructions for each glyph; n is the number of instructions.
                BYTE 	flags[numberOfContours];// 	Array of flags for each coordinate in outline; n is the number of flags.
                SHORT 	xCoordinates;// 	First coordinates relative to (0,0); others are relative to previous point.
                SHORT 	yCoordinates;// 	First coordinates relative to (0,0); others are relative to previous point.
            }
            else if(numberOfContours == -1)
            {
                local USHORT ARG_1_AND_2_ARE_WORDS = 1;
                local USHORT WE_HAVE_A_SCALE = 4;
                local USHORT WE_HAVE_AN_X_AND_Y_SCALE = 32;
                local USHORT WE_HAVE_A_TWO_BY_TWO = 64;
                local USHORT MORE_COMPONENTS = 16;
                local USHORT WE_HAVE_INSTRUCTIONS = 128;
                
                do
                {
	                USHORT flags;
	                USHORT glyphIndex;
	                if ( flags & ARG_1_AND_2_ARE_WORDS)
                    {
	                    SHORT argument1;
	                    SHORT argument2;
	                } else {
		                USHORT arg1and2; /* (arg1 << 8) | arg2 */
	                }
	                if ( flags & WE_HAVE_A_SCALE )
                    {
		                F2DOT14  scale;    /* Format 2.14 */
	                } else if ( flags & WE_HAVE_AN_X_AND_Y_SCALE ) {
		                F2DOT14  xscale;    /* Format 2.14 */
		                F2DOT14  yscale;    /* Format 2.14 */
	                } else if ( flags & WE_HAVE_A_TWO_BY_TWO ) {
		                F2DOT14  xscale;    /* Format 2.14 */
		                F2DOT14  scale01;   /* Format 2.14 */
		                F2DOT14  scale10;   /* Format 2.14 */
		                F2DOT14  yscale;    /* Format 2.14 */
	                }
                } while ( flags & MORE_COMPONENTS );
        
                if (flags & WE_HAVE_INSTR)
                {
	                USHORT numInstr;
	                BYTE instr[numInstr];
                }
            }
        } stuff;
    }
};

typedef struct LocaTable
{
    ushort offsets[g_numGlyphs - 1];
};

typedef struct VorgTable
{
    USHORT 	majorVersion; // 	Major version (starting at 1). Set to 1.
    USHORT 	minorVersion; // 	Minor version (starting at 0). Set to 0.
    SHORT	defaultVertOriginY; //	The y coordinate of a glyph's vertical origin, in the font's design coordinate system, to be used if no entry is present for the glyph in the vertOriginYMetrics array.
    USHORT 	numVertOriginYMetrics; //	Number of elements in the vertOriginYMetrics array.

    struct VertOriginYMetrics
    {  
        USHORT	glyphIndex;
        SHORT 	vertOriginY;
    } metrics[numVertOriginYMetrics];
};

typedef struct sbitLineMetrics
{
    CHAR 	ascender;
    CHAR 	descender;
    BYTE 	widthMax;
    CHAR 	caretSlopeNumerator;
    CHAR 	caretSlopeDenominator;
    CHAR 	caretOffset;
    CHAR 	minOriginSB;
    CHAR 	minAdvanceSB;
    CHAR 	maxBeforeBL;
    CHAR 	minAfterBL;
    CHAR 	pad1;
    CHAR 	pad2;
};

typedef struct EbscTable
{
    Fixed   version;
    ULONG   numSizes;

    struct BitmapScaleTable
    {
        sbitLineMetrics 	hori;  // 	line metrics
        sbitLineMetrics 	vert;  // 	line metrics
        BYTE 	ppemX;  // 	target horizontal pixels per Em
        BYTE 	ppemY;  // 	target vertical pixels per Em
        BYTE 	substitutePpemX;  // 	use bitmaps of this size
        BYTE 	substitutePpemY;  // 	use bitmaps of this size
    } bitmapScaleTable[numSizes];
};

typedef struct BaseCoordTable
{
    uint16  BaseCoordFormat;

    switch(BaseCoordFormat)
    {
    case 1:
        int16  Coordinate;
        break;
    case 2:
        int16   Coordinate;
 //       GliphID ReferenceGlyph;
        uint16  BaseCoordPoint;
        break;
    case 3:
        int16   Coordinate;
        Offset  DeviceTableOffset;
        FSeek(DeviceTableOffset);
        DeviceTable deviceTable;
        break;
    default:
        Printf("Failure 1229\n"); Exit(1);
    }
};

typedef struct MinMaxTable
{
    local uint  MinMaxTablePos = FTell();
    Offset  MinCoord;
    Offset  MaxCoord;
    uint16  FeatMinMaxCount;
    struct FeatMinMaxRecord
    {
        Tag FeatureTableTag;
        Offset  MinCoord;
        Offset  MaxCoord;

        if(MinCoord != 0)
        {
            FSeek(MinMaxTablePos+MinCoord);
            BaseCoordTable minCoordTable;
        }

        if(MaxCoord != 0)
        {
            FSeek(MinMaxTablePos+MaxCoord);
            BaseCoordTable maxCoordTable;
        }

    } featMinMaxRecord[FeatMinMaxCount];

    if(MinCoord != 0)
    {
        FSeek(MinMaxTablePos+MinCoord);
        BaseCoordTable minCoordTable;
    }

    if(MaxCoord != 0)
    {
        FSeek(MinMaxTablePos+MaxCoord);
        BaseCoordTable maxCoordTable;
    }
};

typedef struct BaseTable
{
    local uint BaseTablePos = FTell();

    Fixed   Version;
    Offset  HorizAxis;
    Offset  VertAxis;

    if(HorizAxis != 0)
    {
        FSeek(BaseTablePos + HorizAxis);
        struct HorizAxisTable
        {
            Offset  BaseTagList;
            Offset  BaseScriptList;
        } horizAxisTable;
    }

    if(VertAxis != 0)
    {
        FSeek(BaseTablePos + VertAxis);
        struct VertAxisTable
        {
            local uint AxisTablePos = FTell();
            
            Offset  BaseTagList;
            Offset  BaseScriptList;
            
            if(BaseTagList != 0)
            {
                FSeek(AxisTablePos + BaseTagList);
                struct BaseTagListTable
                {
                    uint16  BaseTagCount;
                    Tag     BaselineTag[BaseTagCount];
                } baseTagListTable;
            }

            if(BaseScriptList != 0)
            {
                FSeek(AxisTablePos + BaseScriptList);
                struct BaseScriptListTable
                {
                    uint16  BaseScriptCount;
                    
                    struct BaseScriptRecord
                    {
                        Tag BaseScriptTag;
                        Offset BaseScript;

                        FSeek(AxisTablePos + BaseScriptList + BaseScript);
                        struct BaseScriptTable
                        {
                            local uint BaseScriptTablePos = FTell();
                            Offset  BaseValues;
                            Offset  DefaultMinMax;
                            uint16  BaseLangSysCount;
                            struct BaseLangSysRecord
                            {
                                Tag BaseLangSysTag;
                                Offset MinMax;
                            } baseLangSysRecord[BaseLangSysCount];
                            
                            if (BaseValues != 0)
                            {
                                FSeek(BaseScriptTablePos + BaseValues);
                                struct BaseValuesTable
                                {
                                    local uint BaseValuesTablePos = FTell();
                                    uint16  DefaultIndex;
                                    uint16  BaseCoordCount;
                                    Offset  BaseCoord[BaseCoordCount];
                                    local int i;
                                    for(i = 0; i<BaseCoordCount; i++)
                                    {
                                        FSeek(BaseValuesTablePos + BaseCoord[i]);
                                    }
                                } baseValuesTable;
                            }
                        } baseScriptTable;

                    } baseScriptRecord[BaseScriptCount];
                } baseScriptlistTable;
            }
        } vertAxisTable;
    }
};

typedef struct GdefTable
{
    local uint GdefTablePos = FTell();

    Fixed 	Version; // 	Version of the GDEF table-initially 0x00010000
    Offset 	GlyphClassDef; // 	Offset to class definition table for glyph type-from beginning of GDEF header (may be NULL)
    Offset 	AttachList; // 	Offset to list of glyphs with attachment points-from beginning of GDEF header (may be NULL)
    Offset 	LigCaretList; // 	Offset to list of positioning points for ligature carets-from beginning of GDEF header (may be NULL)
    Offset 	MarkAttachClassDef; // 	Offset to class definition table for mark attachment type-from beginning of GDEF header (may be NULL)

    if(GlyphClassDef != 0)
    {
        FSeek(GdefTablePos+GlyphClassDef);
        ClassDefinitionTable GlyphClassDefTable;
    }

    if(AttachList != 0)
    {
        FSeek(GdefTablePos+AttachList);
        Offset Coverage;
        uint16  GlyphCount;
        Offset AttachPoint[GlyphCount];

        local int i;
        for(i = 0; i<GlyphCount; i++)
        {
            FSeek(GdefTablePos+AttachList+AttachPoint[i]);
            struct AttachPointTable
            {
                uint16  PointCount;
                uint16  PointIndex[PointCount];
            } attachPointTable;
        }

        FSeek(GdefTablePos + AttachList + Coverage);
        CoverageTable coverageTable;
    }

    if(LigCaretList != 0)
    {
        FSeek(GdefTablePos+LigCaretList);
        Offset Coverage;
        uint16  LigGlyphCount;
        Offset  LogGlyph[LigGlyphCount];

        local int i;
        for(i = 0; i<LigGlyphCount; i++)
        {
            FSeek(GdefTablePos+LigCaretList+LogGlyph[i]);
            struct LigGlyphTable
            {
                uint16  CaretCount;
                Offset  CaretValue[CaretCount];

                local int x;
                for(x = 0; x<CaretCount; x++)
                {
                    FSeek(GdefTablePos+LigCaretList+LogGlyph[i]+CaretValue[x]);
                    struct CaretValueTable
                    {
                        uint16  CaretValueFormat;
                        switch(CaretValueFormat)
                        {
                        case 1:
                            int16   Coordinate;
                            break;
                        case 2:
                            uint16 	CaretValuePoint;
                            break;
                        case 3:
                            int16 	Coordinate;
                            Offset 	DeviceTableOffset;
                            FSeek(GdefTablePos+LigCaretList+LogGlyph[i]+CaretValue[x]+DeviceTableOffset);
                            DeviceTable deviceTable;
                        default:
                            Printf("Failure 1435\n"); Exit(1);
                        }
                    } caretValueTable;
                }
            } ligGlyphTable;
        }

        FSeek(GdefTablePos+LigCaretList+Coverage);
        CoverageTable coverageTable;
    }

    if(MarkAttachClassDef != 0)
    {
        FSeek(GdefTablePos+MarkAttachClassDef);
        ClassDefinitionTable MarkAttachClassTable;
    }
};

typedef struct GposTable
{
    local uint  GposTablePos = FTell();
    Fixed 	Version;
    Offset 	ScriptList;
    Offset 	FeatureList;
    Offset 	LookupList;

    FSeek(GposTablePos+ScriptList);
    ScriptListTable scriptListTable;

    FSeek(GposTablePos+FeatureList);
    FeatureListTable  featureListTable;

    FSeek(GposTablePos+LookupList);
    LookupListTable lookupList;
};

typedef struct GsubTable
{
    local uint  GposTablePos = FTell();
    Fixed 	Version;
    Offset 	ScriptList;
    Offset 	FeatureList;
    Offset 	LookupList;

    FSeek(GposTablePos+ScriptList);
    ScriptListTable scriptListTable;

    FSeek(GposTablePos+FeatureList);
    FeatureListTable  featureListTable;

    FSeek(GposTablePos+LookupList);
    struct 
    {
        local uint  LookupListTablePos = FTell();
        uint16  LookupCount;
        Offset  Lookup[LookupCount];
    
        local int i;
        for(i = 0; i<LookupCount; i++)
        {
            FSeek(LookupListTablePos + Lookup[i]);
            struct 
            {
                local uint LookupTablePos = FTell();
                uint16 	LookupType;
                uint16 	LookupFlag;
                uint16 	SubTableCount;
                Offset 	_SubTable[SubTableCount];
                
                local int x;
                for(x = 0; x<SubTableCount; x++)
                {
                    g_PosTablePos = LookupTablePos + _SubTable[x];
                    FSeek(g_PosTablePos);
    
                    struct
                    {
                        switch(LookupType)
                        {
                        case 1:
                            uint16 	PosFormat;
                            switch(PosFormat)
                            {
                            case 1:
                                Offset  	Coverage;
                                int16 	DeltaGlyphID;
                                break;
                            case 2:
                                Offset  	Coverage;
                                uint16 	GlyphCount;
                                GlyphID 	Substitute[GlyphCount];
                                break;
                            }
                            FSeek(g_PosTablePos+Coverage);
                            CoverageTable coverageTable;
                            break;
    
                        case 2:
                            uint16 	PosFormat;
                            Offset  Coverage;
                            uint16 	SequenceCount;
                            Offset 	Sequence[SequenceCount];
                        
                            local int j;
                            for(j = 0; j<SequenceCount; j++)
                            {
                                FSeek(g_PosTablePos+Sequence[j]);
                                struct SequenceTable
                                {
                                    uint16  	GlyphCount;
                                    GlyphID 	Substitute[GlyphCount];
                                } sequenceTable;
                            }

                            FSeek(g_PosTablePos+Coverage);
                            CoverageTable coverageTable;
                            break;
    
                        case 3:
                            uint16 	PosFormat;
                            Offset  Coverage;
                            uint16 	AlternateSetCount;
                            Offset 	AlternateSet[AlternateSetCount];
                                                    
                            local int j;
                            for(j = 0; j<AlternateSetCount; j++)
                            {
                                FSeek(g_PosTablePos+AlternateSet[j]);
                                struct AlternateSetTable
                                {
                                    uint16  GlyphCount;
                                    GlyphID Alternate[GlyphCount];
                                } alternateSetTable;
                            }

                            FSeek(g_PosTablePos+Coverage);
                            CoverageTable coverageTable;
                            break;
    
                        case 4:
                            uint16 	PosFormat;
                            Offset  Coverage;
                            uint16 	LigSetCount;
                            Offset 	LigatureSet[LigSetCount];
                                                                                
                            local int j;
                            for(j = 0; j<LigSetCount; j++)
                            {
                                FSeek(g_PosTablePos+LigatureSet[j]);
                                struct LigatureSetTable
                                {
                                    uint16  LigatureCount;
                                    Offset Ligature[LigatureCount];
                                                                                
                                    local int r;
                                    for(r = 0; r<LigatureCount; r++)
                                    {
                                        FSeek(g_PosTablePos+LigatureSet[j]+Ligature[r]);
                                        struct LigatureTable
                                        {
                                            GlyphID  	LigGlyph;
                                            uint16 	CompCount;
                                            GlyphID 	Component[CompCount - 1];
                                        } ligatureTable;
                                    }
                                } alternateSetTable;
                            }

                            FSeek(g_PosTablePos+Coverage);
                            CoverageTable coverageTable;
                            break;
    
                        case 5:
                            typedef struct SubstLookupRecord
                            {
                                uint16  SequenceIndex;
                                uint16 	LookupListIndex;
                            };
                            uint16  SubstFormat;
                            switch(SubstFormat)
                            {
                            case 1:
                                Offset 	Coverage;
                                uint16 	SubRuleSetCount;
                                Offset 	SubRuleSet[SubRuleSetCount];
                            
                                local int j;
                                for(j = 0; j<SubRuleSetCount; j++)
                                {
                                    FSeek(g_PosTablePos+SubRuleSet[j]);
                                    struct SubRuleSetTable
                                    {
                                        uint16  SubRuleCount;
                                        Offset  SubRule[SubRuleCount];
                            
                                        local int r;
                                        for(r = 0; r<SubRuleSetCount; r++)
                                        {
                                            FSeek(g_PosTablePos+SubRuleSet[j]+SubRule[r]);
                                            struct SubRuleTable
                                            {
                                                uint16  GlyphCount;
                                                uint16 	SubstCount;
                                                GlyphID Input[GlyphCount - 1];
                                                SubstLookupRecord 	substLookupRecord[SubstCount];
                                            } subRuleTable;
                                        }
                                    } subRuleSetTable;
                                }
                                
                                FSeek(g_PosTablePos+Coverage);
                                CoverageTable coverageTable;
                                break;
                            case 2:
                                Offset  Coverage;
                                Offset 	ClassDef;
                                uint16 	SubClassSetCnt;
                                Offset 	SubClassSet[SubClassSetCnt];
                            
                                FSeek(g_PosTablePos+ClassDef);
                                ClassDefinitionTable classDef;
                            
                                local int j;
                                for(j = 0; j<SubClassSetCnt; j++)
                                {
                                    FSeek(g_PosTablePos+SubClassSet[j]);
                                    struct SubClassSet
                                    {
                                        uint16  SubClassRuleCnt;
                                        Offset 	SubClassRule[SubClassRuleCount];
                            
                                        local int r;
                                        for(r = 0; r<SubClassRuleCnt; r++)
                                        {
                                            FSeek(g_PosTablePos+SubClassSet[j]+SubClassRule[r]);
                                            struct SubClassRuleTable
                                            {
                                                uint16  GlyphCount;
                                                uint16 	SubstCount;
                                                uint16 	Class[GlyphCount - 1];
                                                SubstLookupRecord 	substLookupRecord[SubstCount];
                                            } subClassRuleTable;
                                        }
                                    } subClassSet;
                                }
                                
                                FSeek(g_PosTablePos+Coverage);
                                CoverageTable coverageTable;
                                break;
                            
                            case 3:
                                uint16  GlyphCount;
                                uint16 	SubstCount;
                                Offset 	Coverage[GlyphCount];
                                SubstLookupRecord 	substLookupRecord[SubstCount];
                            
                                local int j;
                                for(j = 0; j<GlyphCount; j++)
                                {
                                    FSeek(g_PosTablePos+Coverage[j]);
                                    CoverageTable coverageTable;
                                }
                                break;
                            }

                            break;
    
                        case 6:
                            uint16  SubstFormat;
                            switch(SubstFormat)
                            {
                            case 1:
                                Offset 	Coverage;
                                uint16 	ChainSubRuleSetCount;
                                Offset 	ChainSubRuleSet[ChainSubRuleSetCount];
                            
                                local int j;
                                for(j = 0; j<ChainSubRuleSetCount; j++)
                                {
                                    FSeek(g_PosTablePos+ChainSubRuleSet[j]);
                                    struct ChainSubRuleSetTable
                                    {
                                        uint16  ChainSubRuleCount;
                                        Offset 	ChainSubRule[ChainSubRuleCount];
                                        
                                        local int r;
                                        for(r = 0; r<ChainSubRuleCount; r++)
                                        {
                                            FSeek(g_PosTablePos+ChainSubRuleSet[j]+ChainSubRule[r]);
                                            struct ChainSubRuleTable
                                            {
                                                uint16  BacktrackGlyphCount;
                                                GlyphID Backtrack[BacktrackGlyphCount];
                                                uint16 	InputGlyphCount;
                                                GlyphID Input[InputGlyphCount - 1];
                                                uint16 	LookaheadGlyphCount;
                                                GlyphID LookAhead[LookAheadGlyphCount];
                                                uint16 	SubstCount;
                                                SubstLookupRecord 	substLookupRecord[SubstCount];
                                            } chainSubRuleTable;
                                        }
                                    } chainSubRuleSetTable;
                                }
                            
                                FSeek(g_PosTablePos+Coverage);
                                CoverageTable coverageTable;
                                break;
                            case 2:
                                Offset  Coverage;
                                Offset 	BacktrackClassDef;
                                Offset 	InputClassDef;
                                Offset 	LookaheadClassDef;
                                uint16 	ChainSubClassSetCnt;
                                Offset 	ChainSubClassSet[ChainSubClassSetCnt];
                                
                                FSeek(g_PosTablePos+Coverage);
                                CoverageTable coverageTable;
                                
                                FSeek(g_PosTablePos+BacktrackClassDef);
                                ClassDefinitionTable backtrackClassDef;
                                
                                FSeek(g_PosTablePos+InputClassDef);
                                ClassDefinitionTable inputClassDef;
                                
                                FSeek(g_PosTablePos+LookaheadClassDef);
                                CoverageTable coverageTable;
                                
                                local int j;
                                for(j = 0; j<ChainSubClassSetCnt; j++)
                                {
                                    FSeek(g_PosTablePos+ChainSubClassSet[j]);
                                    struct ChainSubClassSetTable
                                    {
                                        uint16  ChainSubClassRuleCnt;
                                        Offset 	ChainSubClassRule[ChainSubClassRuleCnt];
                                        
                                        local int r;
                                        for(r = 0; r<ChainSubClassRuleCnt; r++)
                                        {
                                            FSeek(g_PosTablePos+ChainSubClassSet[j]+ChainSubClassRule[r]);
                                            struct ChainSubClassRuleTable
                                            {
                                                uint16  BacktrackGlyphCount;
                                                uint16 	Backtrack[BacktrackGlyphCount];
                                                uint16 	InputGlyphCount;
                                                uint16 	Input[InputGlyphCount - 1];
                                                uint16 	LookaheadGlyphCount;
                                                uint16 	LookAhead[LookAheadGlyphCount];
                                                uint16 	SubstCount;
                                                SubstLookupRecord substLookupRecord[SubstCount];
                                            } chainSubClassRuleTable;
                                        }
                                    } chainSubClassSetTable;
                                }
                                break;
                            case 3:
                                uint16  BacktrackGlyphCount;
                                Offset 	Coverage1[BacktrackGlyphCount];
                                uint16 	InputGlyphCount;
                                Offset 	Coverage2[InputGlyphCount];
                                uint16 	LookaheadGlyphCount;
                                Offset 	Coverage3[LookaheadGlyphCount];
                                uint16 	SubstCount;
                                SubstLookupRecord 	substLookupRecord[SubstCount];
                                
                                local int j;
                                for(j = 0; j<BacktrackGlyphCount; j++)
                                {
                                    FSeek(g_PosTablePos+Coverage1[j]);
                                    CoverageTable coverage1;
                                }
                            
                                for(j = 0; j<InputGlyphCount; j++)
                                {
                                    FSeek(g_PosTablePos+Coverage2[j]);
                                    CoverageTable coverage2;
                                }
                            
                                for(j = 0; j<LookaheadGlyphCount; j++)
                                {
                                    FSeek(g_PosTablePos+Coverage3[j]);
                                    CoverageTable coverage3;
                                }
                            
                                break;
                            }
                            break;
    
                        case 7:
                            USHORT  SubstFormat;
                            USHORT 	ExtensionLookupType;
                            ULONG 	ExtensionOffset;
                            Printf("ERROR: Do not support extension sub-types.\n");
                            Exit(0);
                            break;
                        }
                    } _subTable;
                }
            } lookupTable;
        }
    } lookupList;
};

typedef struct JstfTable
{
    Printf("[!] - JstfTable not supported yet!\n");
};

typedef struct DsigTable
{
    local uint  DsigTablePos = FTell();
    local uint  Pos;
    ULONG 	ulVersion;
    USHORT 	usNumSigs;
    USHORT 	usFlag;

    local uint i;
    for(i = 0; i<usNumSigs; i++)
    {
        ULONG 	ulFormat;
        ULONG 	ulLength;
        ULONG 	ulOffset;
        
        Pos = FTell();
        FSeek(DsigTablePos+ulOffset);

        struct SignatureBlock
        {
            USHORT 	usReserved1;
            USHORT 	usReserved2;
            ULONG 	cbSignature;
            BYTE  	bSignature[cbSignature];
        } signatureBlock;

        FSeek(Pos);
    }
};

typedef struct GaspTable
{
    USHORT 	version;
    USHORT 	numRanges;

    struct GaspRange
    {
        USHORT 	rangeMaxPPEM;
        USHORT 	rangeGaspBehavior;
    } gaspRange[numRanges];
};

typedef struct HdmxTable
{
    USHORT  version;
    SHORT   numRecords;
    LONG    sizeDeviceRecord;
    
    struct DeviceRecord
    {
        ubyte data[sizeDeviceRecord];
    } records[numRecords]<optimize=false>;
};

typedef struct KernTable
{
    Printf("[!] - KernTable not supported yet!\n");
};

typedef struct LtshTable
{
    USHORT 	version;
    USHORT 	numGlyphs;
    BYTE 	yPels[numGlyphs];
};

typedef struct PcltTable
{
    Fixed 	Version;
    ULONG 	FontNumber;
    USHORT 	Pitch;
    USHORT 	xHeight;
    USHORT 	Style;
    USHORT 	TypeFamily;
    USHORT 	CapHeight;
    USHORT 	SymbolSet;
    CHAR 	Typeface[16];
    CHAR 	CharacterComplement[8];
    CHAR 	FileName[6];
    CHAR 	StrokeWeight;
    CHAR 	WidthType;
    BYTE 	SerifStyle;
    BYTE 	Reserved;
};

typedef struct Ratio
{
    BYTE 	bCharSet;
    BYTE 	xRatio;
    BYTE 	yStartRatio;
    BYTE 	yEndRatio;
};

typedef struct VdmxTable
{
    local uint VdmxTablePos = FTell();
    USHORT 	version;
    USHORT 	numRecs;
    USHORT 	numRatios;
    Ratio 	ratRange[numRatios];
    USHORT 	offset[numRatios];

    local uint i;
    for(i = 0; i<numRatios; i++)
    {
        FSeek(VdmxTablePos+offset[i]);
        struct
        {
            USHORT 	recs;
            BYTE 	startsz;
            BYTE 	endsz;
            struct
            {
                USHORT 	yPelHeight;
                SHORT 	yMax;
                SHORT 	yMin;
            } entry[recs];
        } groups;
    }
};

typedef struct VheaTable
{
    Printf("[!] - VheaTable not supported yet!\n");
};

typedef struct VmtxTable
{
    Printf("[!] - VmtxTable not supported yet!\n");
};


OffsetTable offsetTable;
TableDirectory  tableDirectory[offsetTable.numTables];

local uint16 i;

// Run these first.
for(i = 0; i<offsetTable.numTables; i++)
{
    FSeek(tableDirectory[i].offset);
    g_tableDirectory_length = tableDirectory[i].length;

    if(tableDirectory[i].tag == "maxp")
    {
        MaxpTable   table;
    }
}

for(i = 0; i<offsetTable.numTables; i++)
{
    FSeek(tableDirectory[i].offset);
    g_tableDirectory_length = tableDirectory[i].length;

    if(tableDirectory[i].tag == "maxp")
    {
        continue;
    }

    if(tableDirectory[i].tag == "cmap")
    {
        CmapTable   table;
    }
    else if(tableDirectory[i].tag == "head")
    {
        HeadTable   table;
    }
    else if(tableDirectory[i].tag == "hhea")
    {
        HheaTable   table;
    }
    else if(tableDirectory[i].tag == "hmtx")
    {
        HmtxTable   table;
    }
    else if(tableDirectory[i].tag == "name")
    {
        NameTable   table;
    }
    else if(tableDirectory[i].tag == "OS/2")
    {
        Os2Table   table;
    }
    else if(tableDirectory[i].tag == "post")
    {
        PostTable   table;
    }
    else if(tableDirectory[i].tag == "cvt")
    {
        CvtTable   table;
    }
    else if(tableDirectory[i].tag == "fpgm")
    {
        FpgmTable   table;
    }
    else if(tableDirectory[i].tag == "glyf")
    {
        GlyfTable   table;
    }
    else if(tableDirectory[i].tag == "loca")
    {
        LocaTable   table;
    }
    else if(tableDirectory[i].tag == "prep")
    {
        struct PrepTable
        {
            ubyte data[tableDirectory[i].length];
        } table;
    }
    else if(tableDirectory[i].tag == "CCF")
    {
        struct CcfTable
        {
            ubyte data[tableDirectory[i].length];
        } table;
    }
    else if(tableDirectory[i].tag == "VORG")
    {
        VorgTable   table;
    }
    else if(tableDirectory[i].tag == "EBDT")
    {
        struct EbdtTable
        {
            ubyte data[tableDirectory[i].length];
        } table;
    }
    else if(tableDirectory[i].tag == "EBLC")
    {
        struct EblcTable
        {
            ubyte data[tableDirectory[i].length];
        } table;
    }
    else if(tableDirectory[i].tag == "EBSC")
    {
        EbscTable   table;
    }
    else if(tableDirectory[i].tag == "BASE")
    {
        BaseTable   table;
    }
    else if(tableDirectory[i].tag == "GDEF")
    {
        GdefTable   table;
    }
    else if(tableDirectory[i].tag == "GPOS")
    {
        GposTable   table;
    }
    else if(tableDirectory[i].tag == "GSUB")
    {
        GsubTable   table;
    }
    else if(tableDirectory[i].tag == "JSTF")
    {
        JstfTable   table;
    }
    else if(tableDirectory[i].tag == "DSIG")
    {
        DsigTable   table;
    }
    else if(tableDirectory[i].tag == "gasp")
    {
        GaspTable   table;
    }
    else if(tableDirectory[i].tag == "hdmx")
    {
        HdmxTable   table;
    }
    else if(tableDirectory[i].tag == "kern")
    {
        KernTable   table;
    }
    else if(tableDirectory[i].tag == "LTSH")
    {
        LtshTable   table;
    }
    else if(tableDirectory[i].tag == "PCLT")
    {
        PcltTable   table;
    }
    else if(tableDirectory[i].tag == "VDMX")
    {
        VdmxTable   table;
    }
    else if(tableDirectory[i].tag == "vhea")
    {
        VheaTable   table;
    }
    else if(tableDirectory[i].tag == "vmtx")
    {
        VmtxTable   table;
    }
    else
    {
        struct UnknownTable
        {
            ubyte data[tableDirectory[i].length];
        } table;
    }
}

//ubyte fontData[];

// end
